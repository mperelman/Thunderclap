<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thunderclap AI - Banking History</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #f0d38a 0%, #c9a227 50%, #8a6e1e 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
            flex-direction: row;
            justify-content: space-between;
        }
        .brand-text { display: flex; flex-direction: column; }
        .brand img.logo {
            width: 176px;
            height: 176px;
            object-fit: contain;
            image-rendering: -webkit-optimize-contrast;
        }
        .brand h1 { color: #c9a227; }
        
        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 800px;
            width: 100%;
            padding: 40px;
        }
        
        /* Mobile optimization - Google principle #6 */
        @media (max-width: 768px) {
            body {
                padding: 10px;
                align-items: flex-start;
                padding-top: 20px;
            }
            
            .container {
                padding: 20px;
                border-radius: 15px;
            }
            
            h1 {
                font-size: 1.8em !important;
            }
            
            input[type="text"] {
                font-size: 16px !important; /* Prevents iOS zoom */
            }
            
            button {
                padding: 18px !important; /* Thumb-friendly tap target */
                font-size: 1.05em !important;
            }
            
            .suggested-questions li {
                padding: 15px !important; /* Larger tap targets */
            }
        }
        
        h1 {
            color: #c9a227;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            transition: border 0.3s;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: #c9a227;
        }
        
        button {
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
            background: linear-gradient(135deg, #e0c15c 0%, #b38728 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .result {
            margin-top: 30px;
            padding: 30px;
            background: #ffffff;
            border-radius: 15px;
            border: 2px solid #e8e8e8;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            display: none;
        }
        
        .result.show {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .result h2 {
            color: #c9a227;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 10px;
        }
        
        #answer {
            color: #333;
            line-height: 1.8;
            font-size: 1.05em;
        }
        
        #answer h2 {
            color: #c9a227;
            margin-top: 25px;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.5em;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 8px;
        }
        
        #answer h3 {
            color: #555;
            font-size: 1.2em;
            margin-top: 20px;
            margin-bottom: 12px;
            font-weight: 600;
        }
        
        #answer p {
            margin-bottom: 15px;
            line-height: 1.8;
        }
        
        #answer strong {
            color: #333;
            font-weight: 600;
        }
        
        #answer em {
            font-style: italic;
            color: #555;
        }
        
        .suggested-questions {
            margin-top: 30px;
            padding: 25px;
            background: #fbf3cf;
            border-radius: 12px;
            border-left: 4px solid #c9a227;
        }
        
        .suggested-questions h3 {
            color: #c9a227;
            font-size: 1.2em;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .suggested-questions ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .suggested-questions li {
            padding: 12px 15px;
            margin-bottom: 10px;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
            font-size: 0.95em;
        }
        
        .suggested-questions li:before {
            content: "→ ";
            color: #c9a227;
            font-weight: bold;
            margin-right: 5px;
        }
        
        .suggested-questions li:hover {
            background: #c9a227;
            color: white;
            transform: translateX(5px);
            border-color: #c9a227;
        }
        
        .suggested-questions li:hover:before {
            color: white;
        }
        
        .loading {
            text-align: center;
            padding: 30px;
            display: none;
        }
        
        .loading.show {
            display: block;
        }
        
        .loading-details {
            margin-top: 15px;
            color: #c9a227;
            font-size: 0.95em;
            line-height: 1.6;
        }
        
        .loading-tip {
            margin-top: 10px;
            color: #888;
            font-size: 0.85em;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #c9a227;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error {
            background: #fee;
            border-left-color: #f44336;
        }
        
        .attribution {
            text-align: center;
            margin-top: 20px;
            color: #999;
            font-size: 0.9em;
        }
        
        .search-guide {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .search-guide h3 {
            margin-top: 0;
            color: #333;
            font-size: 1.15em;
        }
        
        .search-guide p {
            margin-top: 6px;
            color: #666;
            font-size: 0.9em;
        }
        
        .search-categories {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }
        
        .quick-query {
            background: white;
            border: 2px solid #e0c15c;
            color: #5a4a12;
            padding: 10px 14px;
            border-radius: 999px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        
        .quick-query:hover {
            border-color: #c9a227;
            color: #c9a227;
            transform: translateY(-2px);
        }
        
        .secondary-btn {
            width: 100%;
            padding: 12px;
            font-size: 1em;
            background: white;
            color: #c9a227;
            border: 2px solid #c9a227;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            margin-top: 10px;
        }
        
        .secondary-btn:hover {
            background: #c9a227;
            color: white;
        }
        
    </style>
</head>
<body>
    <div class="container">
        <div class="brand">
            <div class="brand-text">
                <h1>Thunderclap AI</h1>
                <p class="subtitle">Banking through panics, kin, and shifting identities.</p>
            </div>
            <img class="logo" src="./public/img/thunderclap_emblem.png?v=2" alt="Thunderclap emblem" onerror="this.style.display='none';" />
        </div>
        
        <div class="search-guide">
            <p style="margin-bottom: 15px; color: #555;">Use the search box below or open the sampler to pick a topic.</p>
            <button class="secondary-btn" onclick="showIndexed()">View Sample Terms</button>
        </div>
        
        <div class="input-group">
            <input 
                type="text" 
                id="question" 
                placeholder="Ask about families, panics, identities, or institutions..."
                maxlength="500"
            >
        </div>
        
        <button onclick="askQuestion()">Ask Thunderclap</button>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p style="margin-top: 10px; color: #c9a227; font-weight: 600;">Researching historical documents...</p>
            <div class="loading-details" id="loading-details">
                Analyzing your query...
            </div>
            <div id="progress-container" style="margin-top:12px; width:100%; background:#eee; border-radius:8px; overflow:hidden; height:10px; display:none;">
                <div id="progress-bar" style="height:100%; width:0%; background:#c9a227; transition: width 0.3s ease;"></div>
            </div>
            <div class="loading-tip" id="loading-tip">
                ⏱️ <span id="time-estimate">Estimating time...</span> | <span id="elapsed-timer">0s</span>
            </div>
        </div>
        
        <div class="result" id="result">
            <h2>Answer</h2>
            <div id="answer"></div>
            <div id="debug-info" style="margin-top:12px; font-size:0.85em; color:#666; display:none;">
                <div>Request ID: <span id="debug-request-id">—</span></div>
                <div>Status: <span id="debug-status">—</span></div>
                <div><a id="debug-link" href="#" target="_blank" style="color:#c9a227; display:none;">View server trace</a></div>
            </div>
            <div id="suggested-questions-container" style="display: none;"></div>
        </div>
        
        <div class="attribution">
            Powered by Thunderclap AI | Data protected and secure
        </div>
    </div>

    <script>
        // IMPORTANT: Change this to your deployed API URL
        // API URL - defaults to localhost, but can be overridden via URL parameter or environment
        const API_URL = (() => {
            const urlParams = new URLSearchParams(window.location.search);
            const apiParam = urlParams.get('api');
            if (apiParam) return apiParam;
            // Try to detect if we're on GitHub Pages and use a default remote server if needed
            if (window.location.hostname.includes('github.io')) {
                // Default to localhost fallback - user should set ?api=YOUR_SERVER_URL
                return 'http://localhost:8000/query';
            }
            return 'http://localhost:8000/query';
        })();
        
        function fillExample(text) {
            document.getElementById('question').value = text;
        }
        
        function extractSuggestedQuestions(text) {
            // Extract suggested questions section - match all common variations
            const patterns = [
                /Here are some potential follow-up questions.*?:\s*([\s\S]*?)$/i,
                /Potential follow-up questions.*?:\s*([\s\S]*?)$/i,
                /Follow-up questions.*?:\s*([\s\S]*?)$/i,
                /\*\*Related Questions:\*\*\s*([\s\S]*?)$/i,
                /\*\*Suggested Questions:\*\*\s*([\s\S]*?)$/i,
                /Related Questions:\s*([\s\S]*?)$/i,
                /Suggested Questions:\s*([\s\S]*?)$/i,
                /\*\*Questions for further exploration:\*\*\s*([\s\S]*?)$/i
            ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    const questionsSection = match[1];
                    const questions = [];
                    
                    // First try: Extract questions separated by asterisks on same line
                    // Pattern: "Question1*   Question2*   Question3?"
                    // Handle both "*   " separator and just "*" separator
                    // Split by asterisk (with optional spaces around it)
                    const asteriskSeparated = questionsSection.split(/\s*\*\s*/);
                    if (asteriskSeparated.length > 1) {
                        const asteriskMatches = [];
                        for (const part of asteriskSeparated) {
                            const q = part.trim();
                            // Check if it looks like a question (ends with ? or starts with question words)
                            if (q.length > 10 && (q.includes('?') || q.match(/^(Tell me|What|Who|How|When|Where|Why)/i))) {
                                // Remove trailing asterisks if any
                                const cleaned = q.replace(/\*+$/, '').trim();
                                if (cleaned.length > 10) {
                                    asteriskMatches.push(cleaned);
                                }
                            }
                        }
                        if (asteriskMatches.length > 0) {
                            const cleanText = text.substring(0, match.index).trim();
                            return { text: cleanText, questions: asteriskMatches };
                        }
                    }
                    
                    // Also try: Questions on same line separated by multiple spaces and asterisks
                    // Pattern: "Question1*   Question2*   Question3?"
                    const inlineAsteriskPattern = /([^*?]+(?:[?]|Tell me|What|Who|How|When|Where|Why)[^*]*)/gi;
                    const inlineMatches = [];
                    let inlineMatch;
                    while ((inlineMatch = inlineAsteriskPattern.exec(questionsSection)) !== null) {
                        const q = inlineMatch[1].trim();
                        if (q.length > 10) {
                            inlineMatches.push(q);
                        }
                    }
                    if (inlineMatches.length > 1) {
                        const cleanText = text.substring(0, match.index).trim();
                        return { text: cleanText, questions: inlineMatches };
                    }
                    
                    // Second try: Extract questions from lines (numbers or bullets)
                    // First, normalize the text - handle cases where questions are split incorrectly
                    // CRITICAL: Handle questions concatenated on one line: "Boston?2. How did..." -> "Boston?\n2. How did..."
                    // Split BEFORE the number pattern, not after the question mark
                    let normalizedSection = questionsSection;
                    // Pattern: question mark followed immediately by number: "?2." -> "?\n2."
                    normalizedSection = normalizedSection.replace(/([?])(\d+)\./g, '$1\n$2.');
                    // Pattern: question mark, space(s), then number: "? 2." -> "?\n2."
                    normalizedSection = normalizedSection.replace(/([?])\s+(\d+)\./g, '$1\n$2.');
                    // Pattern: Handle concatenated questions like "RR contribute to the Panic of 1901?3. What actions did"
                    // Split on number pattern even if it comes after a question mark on same line
                    normalizedSection = normalizedSection.replace(/([?])(\d+)\./g, '$1\n$2.');
                    // Also handle if questions are on same line without question marks: "Boston.2. How..." -> "Boston.\n2. How..."
                    // But only if preceded by a word (not already a number)
                    normalizedSection = normalizedSection.replace(/([a-zA-Z])(\d+)\./g, '$1\n$2.');
                    // CRITICAL: Also handle bullets that might be concatenated: "* Question 1?* Question 2?" -> "* Question 1?\n* Question 2?"
                    normalizedSection = normalizedSection.replace(/([?])\s*(\*)/g, '$1\n$2');
                    // Handle bullets without question marks: "Question 1* Question 2" -> "Question 1\n* Question 2"
                    normalizedSection = normalizedSection.replace(/([a-zA-Z])\s*(\*)/g, '$1\n$2');
                    
                    // CRITICAL: Handle incomplete questions that start mid-sentence
                    // If a line doesn't start with a number, bullet, or question word, it's likely a continuation or incomplete
                    // Check if first "question" starts mid-sentence and remove it
                    const firstLine = normalizedSection.split('\n')[0]?.trim() || '';
                    const questionStartPattern = /^(What|Who|How|When|Where|Why|Tell me|Describe|Explain|\d+\.|[-•→*])/i;
                    if (firstLine && !questionStartPattern.test(firstLine) && firstLine.length > 0) {
                        // First line is incomplete - remove it and everything before the first numbered/bulleted question
                        const firstNumberMatch = normalizedSection.match(/(\d+\.)/);
                        const firstBulletMatch = normalizedSection.match(/^[-•→*]/m);
                        if (firstNumberMatch && firstBulletMatch) {
                            // Use whichever comes first
                            const numberIndex = normalizedSection.indexOf(firstNumberMatch[0]);
                            const bulletIndex = normalizedSection.indexOf(firstBulletMatch[0]);
                            const firstIndex = Math.min(numberIndex, bulletIndex);
                            normalizedSection = normalizedSection.substring(firstIndex);
                        } else if (firstNumberMatch) {
                            const firstNumberIndex = normalizedSection.indexOf(firstNumberMatch[0]);
                            normalizedSection = normalizedSection.substring(firstNumberIndex);
                        } else if (firstBulletMatch) {
                            const firstBulletIndex = normalizedSection.indexOf(firstBulletMatch[0]);
                            normalizedSection = normalizedSection.substring(firstBulletIndex);
                        }
                    }
                    
                    // Fallback: If still all on one line, try splitting by number pattern directly
                    // This handles cases like "1. Question?2. Question?3. Question?"
                    if (!normalizedSection.includes('\n') && normalizedSection.match(/\d+\./)) {
                        // Split on number pattern but keep the number with the question
                        normalizedSection = normalizedSection.replace(/(\d+)\./g, '\n$1.');
                        // Remove leading newline
                        normalizedSection = normalizedSection.replace(/^\n+/, '');
                    }
                    
                    const lines = normalizedSection.split('\n');
                    let currentQuestion = '';
                    
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) {
                            // Empty line - if we have a current question, save it
                            if (currentQuestion && currentQuestion.length > 10) {
                                questions.push(currentQuestion.trim());
                                currentQuestion = '';
                            }
                            continue;
                        }
                        
                        // Check if this line starts a new numbered question (e.g., "2. How did...")
                        const numberMatch = line.match(/^(\d+)\.\s*(.+)$/);
                        if (numberMatch) {
                            // Save previous question if we have one
                            if (currentQuestion && currentQuestion.length > 10) {
                                questions.push(currentQuestion.trim());
                            }
                            // Start new question
                            currentQuestion = numberMatch[2];
                        }
                        // Check if this line starts a bullet question (e.g., "* Question?" or "- Question?")
                        else if (line.match(/^[-•→*]\s*(.+)$/)) {
                            const bulletMatch = line.match(/^[-•→*]\s*(.+)$/);
                            if (bulletMatch) {
                                // Save previous question if we have one
                                if (currentQuestion && currentQuestion.length > 10) {
                                    questions.push(currentQuestion.trim());
                                }
                                // Start new question
                                currentQuestion = bulletMatch[1];
                            }
                        }
                        // If we're building a question, continue appending to it
                        else if (currentQuestion) {
                            // Append to current question (handles multi-line questions)
                            // But stop if we hit a new question marker
                            if (line.match(/^\d+\./)) {
                                // This is a new numbered question - save current and start new
                                if (currentQuestion.length > 10) {
                                    questions.push(currentQuestion.trim());
                                }
                                const newMatch = line.match(/^\d+\.\s*(.+)$/);
                                currentQuestion = newMatch ? newMatch[1] : '';
                            } else if (line.match(/^[-•→*]\s*(.+)$/)) {
                                // This is a new bullet question - save current and start new
                                if (currentQuestion.length > 10) {
                                    questions.push(currentQuestion.trim());
                                }
                                const bulletMatch = line.match(/^[-•→*]\s*(.+)$/);
                                currentQuestion = bulletMatch ? bulletMatch[1] : '';
                            } else {
                                currentQuestion += ' ' + line;
                            }
                        }
                        // Standalone question ending with ?
                        else if (line.length > 10 && line.endsWith('?') && !line.match(/^\d+\./)) {
                            questions.push(line);
                        }
                    }
                    
                    // Don't forget the last question
                    if (currentQuestion && currentQuestion.length > 10) {
                        questions.push(currentQuestion.trim());
                    }
                    
                    // Basic validation - only filter obviously broken questions
                    // The LLM should generate complete questions, so we only catch clear errors
                    questions = questions.filter(q => {
                        const cleaned = q.trim();
                        // Remove questions that are just numbers or very short
                        if (cleaned.length < 15) return false;
                        // Remove questions that are just fragments
                        if (cleaned.match(/^[\d\s\.\?]+$/)) return false;
                        // Basic check: questions should end with "?"
                        if (!cleaned.endsWith('?')) {
                            console.warn('Question missing question mark:', cleaned);
                            return false;
                        }
                        return true;
                    });
                    
                    if (questions.length > 0) {
                        // Remove the questions section from original text
                        const cleanText = text.substring(0, match.index).trim();
                        return { text: cleanText, questions: questions };
                    }
                }
            }
            
            return { text: text, questions: [] };
        }
        
        function displaySuggestedQuestions(questions) {
            const container = document.getElementById('suggested-questions-container');
            if (questions.length === 0) {
                container.style.display = 'none';
                return;
            }
            
            // Debug: log questions to console
            console.log('Extracted questions:', questions);
            console.log('Number of questions:', questions.length);
            
            // Build HTML with individual clickable items
            // Filter out incomplete questions one more time before display
            const validQuestions = questions.filter(q => {
                const cleaned = q.trim();
                // Must be at least 15 chars
                if (cleaned.length < 15) return false;
                // Must start with question word or capital letter
                const questionStartPattern = /^(What|Who|How|When|Where|Why|Tell me|Describe|Explain|What was|What were|What is|What are|How did|How does|How do|When did|When does|Where did|Where does|Why did|Why does)/i;
                if (!questionStartPattern.test(cleaned) && !cleaned.match(/^[A-Z]/)) {
                    return false;
                }
                // Must not end with incomplete words
                const incompletePattern = /\b(with|of|to|for|in|on|at|by|from|about|into|onto|upon|the|a|an)\s*$/i;
                if (incompletePattern.test(cleaned) && !cleaned.endsWith('?')) {
                    return false;
                }
                return true;
            });
            
            let html = '<div class="suggested-questions"><h3>Related Questions</h3><ul>';
            for (let i = 0; i < validQuestions.length; i++) {
                const q = validQuestions[i].trim();
                // Escape single quotes for onclick handler - use JSON.stringify for safer escaping
                const escaped = q.replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/\n/g, ' ').replace(/\r/g, '');
                // Escape HTML for display
                const displayText = q.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                html += `<li onclick="askSuggestedQuestion('${escaped}')">${displayText}</li>`;
            }
            html += '</ul></div>';
            
            container.innerHTML = html;
            container.style.display = 'block';
        }
        
        function askSuggestedQuestion(question) {
            document.getElementById('question').value = question;
            askQuestion();
        }
        
        function formatMarkdown(text) {
            // Simple markdown-to-HTML converter
            let html = text;
            
            // Headers (do ## before # to avoid double-replacement)
            html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
            html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^# (.+)$/gm, '<h2>$1</h2>');  // Treat H1 as H2
            html = html.replace(/^\*\*(.+)\*\*$/gm, '<h3>$1</h3>');
            
            // Bold text
            html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            
            // Italic text (bank names)
            html = html.replace(/\*([^*]+?)\*/g, '<em>$1</em>');
            
            // Line breaks - preserve paragraph structure
            html = html.replace(/\n\n/g, '</p><p>');
            html = '<p>' + html + '</p>';
            
            // Clean up empty paragraphs and paragraphs around headers
            html = html.replace(/<p><\/p>/g, '');
            html = html.replace(/<p>\s*<\/p>/g, '');
            html = html.replace(/<p>(<h[123]>)/g, '$1');
            html = html.replace(/(<\/h[123]>)<\/p>/g, '$1');
            
            return html;
        }
        
        function selectIndexedQuery(query) {
            document.getElementById('question').value = query;
            const modal = document.getElementById('indexed-modal');
            if (modal) modal.remove();
        }

        
        
        function showIndexed() {
            const existingModal = document.getElementById('indexed-modal');
            if (existingModal) existingModal.remove();
            
            const chip = (label, prompt) => `<div class="quick-query" style="margin-bottom:8px;" onclick="selectIndexedQuery('${prompt.replace(/'/g, "\\'")}')">${label}</div>`;
            
            const families = [
                ["Rothschild Paris", "Tell me about Paris Rothschild banking"],
                ["Rothschild London", "Tell me about London Rothschild banking"],
                ["Rothschild Vienna", "Tell me about Vienna Rothschild banking"],
                ["Lazard Paris", "Tell me about Lazard Paris banking"],
                ["Lazard London", "Tell me about Lazard London banking"],
                ["Lazard New York", "Tell me about Lazard New York banking"],
                ["Morgan London", "Tell me about Morgan banking in London"],
                ["Morgan Paris", "Tell me about Morgan banking in Paris"],
                ["Morgan Grenfell", "Tell me about Morgan Grenfell"],
                ["Baring Brothers", "Tell me about Baring Brothers"],
                ["Hope & Co.", "Tell me about Hope banking"],
                ["Warburg Hamburg", "Tell me about the Warburgs in Hamburg"],
                ["Kuhn, Loeb & Co.", "Tell me about Kuhn, Loeb & Co. banking"],
                ["Jacob Schiff", "Tell me about Jacob Schiff"],
                ["Sassoon Bombay", "Tell me about the Sassoons in Bombay"],
                ["Sassoon Shanghai", "Tell me about the Sassoons in Shanghai"],
                ["Kadoorie Hong Kong", "Tell me about the Kadoories in Hong Kong"],
                ["Goldsmid London", "Tell me about Goldsmid bankers"],
                ["Hambro Copenhagen", "Tell me about Hambro bankers"],
                ["Montefiore London", "Tell me about Montefiore bankers"],
                ["Speyer Frankfurt", "Tell me about Speyer bankers"],
                ["Crédit Mobilier", "Tell me about Crédit Mobilier"],
                ["Crédit Lyonnais", "Tell me about Crédit Lyonnais"],
                ["Banque de France", "Tell me about Banque de France"],
                ["National City Bank", "Tell me about National City Bank"],
                ["First National Boston", "Tell me about First National Bank of Boston"],
                ["Bank of America", "Tell me about Bank of America"],
                ["Bank of Montreal", "Tell me about Bank of Montreal"],
                ["Hamburg-America finance", "Tell me about Hamburg-America finance"],
                ["Brown Brothers Harriman", "Tell me about Brown Brothers Harriman"],
                ["Federal Reserve System (FRS)", "Tell me about the Federal Reserve System (FRS)"],
                ["Federal Reserve Bank of New York (FRBNY)", "Tell me about the Federal Reserve Bank of New York (FRBNY)"],
                ["Bank of England (BOE)", "Tell me about the Bank of England (BOE)"],
                ["First Bank of the United States", "Tell me about the First Bank of the United States"],
                ["Second Bank of the United States", "Tell me about the Second Bank of the United States"],
                ["Reconstruction Finance Corporation (RFC)", "Tell me about the Reconstruction Finance Corporation (RFC)"],
                ["Securities and Exchange Commission (US SEC)", "Tell me about the United States Securities and Exchange Commission (SEC)"],
                ["War Finance Corporation", "Tell me about the War Finance Corporation"]
            ];
            
            const markets = [
                ["MMEU (Eurodollar) money market", "Tell me about the MMEU (Eurodollar) money market"],
                ["ABCP (asset-backed commercial paper)", "Tell me about asset-backed commercial paper (ABCP) conduits"],
                ["Long-term capital flows", "Tell me about long-term capital markets"],
                ["Eurodollar offshore deposits", "Tell me about the Eurodollar market (USD offshore)"],
                ["Sukarno-era Indonesian bonds", "Tell me about the Sukarno-era bond market"],
                ["Ottoman debt market", "Tell me about the Ottoman Empire's debt market"],
                ["Colonial silver trade", "Tell me about colonial-era silver markets"],
                ["Railroad securities", "Tell me about railroad securities trading"],
                ["Real estate trusts (REITs)", "Tell me about real estate finance (REITs)"],
                ["Conglomerate stocks", "Tell me about conglomerate equities"],
                ["Technology stocks", "Tell me about technology equities"],
                ["Slave finance markets", "Tell me about slave trading finance"],
                ["DEI investment programs", "Tell me about diversity finance initiatives"]
            ];
            
            const concepts = [
                ["Kinlinks in finance", "Tell me about kinlinks (family networks) in banking"],
                ["Minority middlemen", "Tell me about minority middlemen in finance"],
                ["Cousinhood marriages", "Tell me about cousinhood marriage networks"],
                ["Merchant diasporas", "Tell me about merchant diasporas in banking"],
                ["Cartelization", "Tell me about cartelization in banking"],
                ["Tax farming", "Tell me about tax farming in finance"],
                ["Courtier capitalism", "Tell me about courtier capitalism"],
                ["Socialism & banking", "Tell me about socialism's relationship with banking"],
                ["Marxism & capital", "Tell me about Marxist critiques of banking"],
                ["Nazism & banking", "Tell me about Nazi banking policies"],
                ["Command economies", "Tell me about command economies and finance"],
                ["Capitalism & free markets", "Tell me about capitalist/free-market banking"]
            ];
            
            const identities = [
                ["Sephardim", "Tell me about Sephardim"],
                ["Ashkenazim", "Tell me about Ashkenazim"],
                ["Court Jews", "Tell me about Court Jews"],
                ["Quakers", "Tell me about Quakers"],
                ["Huguenots", "Tell me about Huguenots"],
                ["Puritans", "Tell me about Puritans"],
                ["Greeks", "Tell me about Greeks"],
                ["Catholics", "Tell me about Catholics"],
                ["Templars", "Tell me about Templars"],
                ["Armenians", "Tell me about Armenians"],
                ["Parsees", "Tell me about Parsees"],
                ["Banias", "Tell me about Banias"],
                ["Dalits", "Tell me about Dalits"],
                ["Sunnis", "Tell me about Sunnis"],
                ["Old Believers", "Tell me about Old Believers"],
                ["Boston Brahmin", "Tell me about Boston Brahmin"],
                ["Knickerbockers", "Tell me about Knickerbockers"],
                ["Women", "Tell me about Women"],
                ["Blacks", "Tell me about Blacks"],
                ["Gays", "Tell me about Gays"],
                ["Hispanics", "Tell me about Hispanics"],
                ["Chinese", "Tell me about Chinese"],
                ["Japanese", "Tell me about Japanese"],
                ["Koreans", "Tell me about Koreans"]
            ];
            
            const panics = [
                "Panic of 1763","Panic of 1772","Panic of 1792","Panic of 1819",
                "Panic of 1825","Panic of 1837","Panic of 1847","Panic of 1857",
                "Panic of 1866","Panic of 1873","Panic of 1884","Panic of 1890",
                "Panic of 1893","Panic of 1896","Panic of 1901","Panic of 1907",
                "Panic of 1910","Panic of 1914","Panic of 1920","Panic of 1929",
                "Panic of 1931","Panic of 1973","Panic of 1987","Panic of 1997",
                "Panic of 1998","Panic of 2001","Panic of 2007","Panic of 2008"
            ];
            
            const geographies = [
                ["London", "Tell me about London banking"],
                ["Paris", "Tell me about Paris banking"],
                ["Frankfurt", "Tell me about Frankfurt banking"],
                ["Amsterdam", "Tell me about Amsterdam banking"],
                ["Vienna", "Tell me about Vienna banking"],
                ["Berlin", "Tell me about Berlin banking"],
                ["Moscow", "Tell me about Moscow banking"],
                ["New York", "Tell me about New York banking"],
                ["Boston", "Tell me about Boston banking"],
                ["Bombay", "Tell me about Bombay banking"],
                ["Calcutta", "Tell me about Calcutta banking"],
                ["Shanghai", "Tell me about Shanghai banking"],
                ["Hong Kong", "Tell me about Hong Kong banking"],
                ["Baghdad", "Tell me about Baghdad banking"],
                ["Cairo", "Tell me about Cairo banking"],
                ["Jerusalem", "Tell me about Jerusalem banking"],
                ["Philadelphia", "Tell me about Philadelphia banking"],
                ["Singapore", "Tell me about Singapore banking"],
                ["Ottoman Empire", "Tell me about Ottoman Empire banking"],
                ["British Empire", "Tell me about British imperial banking"],
                ["United Kingdom", "Tell me about British/UK banking"],
                ["United States", "Tell me about United States banking"],
                ["France", "Tell me about French banking"],
                ["Germany", "Tell me about German banking"],
                ["Netherlands", "Tell me about Dutch banking"],
                ["Italy", "Tell me about Italian banking"],
                ["Spain", "Tell me about Spanish banking"],
                ["Portugal", "Tell me about Portuguese banking"],
                ["Switzerland", "Tell me about Swiss banking"],
                ["Scandinavia", "Tell me about Scandinavian banking"],
                ["Russia", "Tell me about Russian banking"],
                ["India", "Tell me about Indian banking"],
                ["China", "Tell me about Chinese banking"],
                ["Japan", "Tell me about Japanese banking"],
                ["Southeast Asia", "Tell me about Southeast Asian banking"],
                ["Middle East", "Tell me about Middle Eastern banking"],
                ["North Africa", "Tell me about North African banking"],
                ["West Africa", "Tell me about West African banking"],
                ["Caribbean", "Tell me about Caribbean banking"],
                ["Latin America", "Tell me about Latin American banking"],
                ["Brazil", "Tell me about Brazilian banking"],
                ["Argentina", "Tell me about Argentine banking"]
            ];
            
            const renderChips = (items) => items.map(item => Array.isArray(item) ? chip(item[0], item[1]) : chip(item, `Tell me about ${item}`)).join('');
            
            const modal = `
                <div id="indexed-modal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 1000; display: flex; align-items: center; justify-content: center;" onclick="this.remove()">
                    <div style="background: white; padding: 30px; border-radius: 15px; max-width: 900px; max-height: 85vh; overflow-y: auto; border:2px solid #c9a227;" onclick="event.stopPropagation()">
                        <h2 style="color: #c9a227; margin-top: 0;">Sample Terms</h2>
                        <p style="color: #444; font-size: 0.95em; margin-bottom: 12px;">Tap any topic below to auto-fill the search bar, or type your own term.</p>
                        <p style="color: #777; font-size: 0.85em; margin-bottom: 18px;">
                            Showing highlighted topics. Type any other term directly in the search bar if you don’t see it listed here.
                        </p>
                        
                        <h3 style="color: #c9a227;">Banking Families & Houses</h3>
                        <div class="search-categories" style="margin-bottom: 15px;">
                            ${renderChips(families)}
                        </div>
                        
                        <h3 style="color: #c9a227;">Identities & Cousinhoods</h3>
                        <div class="search-categories" style="margin-bottom: 15px;">
                            ${renderChips(identities)}
                        </div>
                        
                        <h3 style="color: #c9a227;">Markets & Asset Classes</h3>
                        <div class="search-categories" style="margin-bottom: 15px;">
                            ${renderChips(markets)}
                        </div>
                        
                        <h3 style="color: #c9a227;">Concepts & Themes</h3>
                        <div class="search-categories" style="margin-bottom: 15px;">
                            ${renderChips(concepts)}
                        </div>
                        
                        <h3 style="color: #c9a227;">Financial Panics & Crises</h3>
                        <div class="search-categories" style="margin-bottom: 15px;">
                            ${renderChips(panics)}
                        </div>
                        
                        <h3 style="color: #c9a227;">Geographies</h3>
                        <div class="search-categories" style="margin-bottom: 15px;">
                            ${renderChips(geographies)}
                        </div>
                        
                        <button style="margin-top: 20px; padding: 10px 20px; background: linear-gradient(135deg, #e0c15c 0%, #b38728 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1em;" onclick="this.closest('div').parentElement.remove()">Close</button>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modal);
        }
        
        async function askQuestion() {
            const question = document.getElementById('question').value.trim();
            
            if (!question || question.length < 3) {
                alert('Please enter a question (at least 3 characters)');
                return;
            }
            
            // Show loading with progress updates (Google principle #5: Show progress and status)
            document.getElementById('loading').classList.add('show');
            // Ensure spinner and progress are visible
            document.getElementById('progress-container').style.display = 'block';
            setProgress(8, 'Starting...');
            document.getElementById('result').classList.remove('show');
            document.getElementById('suggested-questions-container').style.display = 'none';
            document.querySelector('button').disabled = true;
            
            // Update loading message based on query size
            const loadingDetails = document.getElementById('loading-details');
            const queryWords = question.split(' ').length;
            if (queryWords < 5) {
                loadingDetails.textContent = 'Searching database... (usually 10-15 seconds)';
            } else {
                loadingDetails.textContent = 'Processing comprehensive query... (may take 30-60 seconds)';
            }
            setProgress(15, 'Collecting terms...');
            
            // Show progress update after 15 seconds
            const progressTimeout = setTimeout(() => {
                loadingDetails.textContent = 'Still processing... analyzing historical documents';
                bumpProgress(10);
            }, 15000);
            // Gentle periodic bumps so users see progress
            const bumps = [];
            bumps.push(setTimeout(() => bumpProgress(10), 2500));
            bumps.push(setTimeout(() => bumpProgress(10), 6000));
            bumps.push(setTimeout(() => bumpProgress(10), 10000));
            bumps.push(setTimeout(() => bumpProgress(10), 20000));
            bumps.push(setTimeout(() => bumpProgress(10), 30000));
            
            async function fetchWithRetry(url, options, retries = 3, baseDelayMs = 800) {
                let attempt = 0;
                while (true) {
                    try {
                        const res = await fetch(url, options);
                        if (res.status === 429 || res.status === 502 || res.status === 503) {
                            if (attempt >= retries) return res;
                            const delay = baseDelayMs * Math.pow(2, attempt);
                            setProgress(Math.min(95, (attempt + 1) * 10 + 30), `Rate limit hit. Retrying in ${Math.ceil(delay/1000)}s...`);
                            await new Promise(r => setTimeout(r, delay));
                            attempt += 1;
                            continue;
                        }
                        return res;
                    } catch (e) {
                        if (attempt >= retries) throw e;
                        const delay = baseDelayMs * Math.pow(2, attempt);
                        setProgress(Math.min(95, (attempt + 1) * 10 + 30), `Network error. Retrying in ${Math.ceil(delay/1000)}s...`);
                        await new Promise(r => setTimeout(r, delay));
                        attempt += 1;
                    }
                }
            }
            
            try {
                setProgress(30, 'Starting query...');
                
                // Start background job - returns immediately to avoid Railway timeout
                const startResponse = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        question: question,
                        max_length: 15000
                    })
                });
                
                if (!startResponse.ok) {
                    if (startResponse.status === 429) {
                        throw new Error('Rate limit exceeded. Please try again later.');
                    }
                    throw new Error('Failed to start query. HTTP ' + startResponse.status);
                }
                
                const jobData = await startResponse.json();
                const jobId = jobData.job_id;
                
                const debugInfo = document.getElementById('debug-info');
                const debugReq = document.getElementById('debug-request-id');
                const debugStatus = document.getElementById('debug-status');
                const debugLink = document.getElementById('debug-link');
                debugReq.textContent = jobId;
                debugStatus.textContent = '202 Accepted';
                debugLink.href = 'http://localhost:8000/debug/last?n=50';
                debugLink.style.display = 'inline';
                debugInfo.style.display = 'block';
                
                setProgress(40, 'Processing query...');
                
                // Poll for completion every 2 seconds
                const pollInterval = 2000; // 2 seconds
                const maxPolls = 210; // 7 minutes max (210 * 2s = 420s)
                let pollCount = 0;
                
                // Start live timer
                let timerStart = Date.now();
                let timerInterval = null;
                timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - timerStart) / 1000);
                    document.getElementById('elapsed-timer').textContent = `${elapsed}s`;
                }, 1000);
                
                // Function to calculate time estimate based on chunk count
                function calculateTimeEstimate(chunkCount) {
                    if (!chunkCount) return null;
                    
                    // Base time: 5-8 seconds for setup and retrieval
                    // Per chunk: ~2-3 seconds for LLM processing (varies with chunk size)
                    // More chunks = longer processing, but not strictly linear
                    const baseTime = 8;
                    const perChunkTime = chunkCount <= 20 ? 2.5 : (chunkCount <= 50 ? 2.0 : 1.8);
                    const estimatedSeconds = Math.ceil(baseTime + (chunkCount * perChunkTime));
                    
                    if (estimatedSeconds < 30) {
                        return `~${estimatedSeconds}s`;
                    } else if (estimatedSeconds < 60) {
                        return `~${estimatedSeconds}s`;
                    } else {
                        const minutes = Math.floor(estimatedSeconds / 60);
                        const seconds = estimatedSeconds % 60;
                        return seconds > 0 ? `~${minutes}m ${seconds}s` : `~${minutes}m`;
                    }
                }
                
                // Function to update time estimate display
                function updateTimeEstimate(chunkCount, elapsed) {
                    const estimateEl = document.getElementById('time-estimate');
                    const estimate = calculateTimeEstimate(chunkCount);
                    
                    if (estimate) {
                        estimateEl.textContent = `${chunkCount} chunks: ${estimate}`;
                    } else if (elapsed > 0) {
                        // Fallback estimate based on elapsed time
                        if (elapsed < 15) {
                            estimateEl.textContent = '~15-30s';
                        } else if (elapsed < 45) {
                            estimateEl.textContent = '~30-60s';
                        } else {
                            estimateEl.textContent = '~1-2min';
                        }
                    } else {
                        estimateEl.textContent = '~15-30s';
                    }
                }
                
                while (pollCount < maxPolls) {
                    await new Promise(r => setTimeout(r, pollInterval));
                    pollCount++;
                    
                    const statusResponse = await fetch(`${API_URL}/${jobId}`);
                    if (!statusResponse.ok) {
                        clearInterval(timerInterval);
                        throw new Error(`Failed to check status. HTTP ${statusResponse.status}`);
                    }
                    
                    const statusData = await statusResponse.json();
                    const elapsed = Math.floor(statusData.elapsed || 0);
                    
                    // Update time estimate if chunk count is available
                    if (statusData.chunk_count) {
                        updateTimeEstimate(statusData.chunk_count, elapsed);
                    } else if (elapsed > 0) {
                        updateTimeEstimate(null, elapsed);
                    }
                    
                    if (statusData.status === 'complete') {
                        clearInterval(timerInterval);
                        setProgress(85, 'Formatting...');
                        
                        // Extract suggested questions
                        const parsed = extractSuggestedQuestions(statusData.answer);
                        
                        // Show result
                        document.getElementById('answer').innerHTML = formatMarkdown(parsed.text);
                        displaySuggestedQuestions(parsed.questions);
                        document.getElementById('result').classList.add('show');
                        document.getElementById('result').classList.remove('error');
                        setProgress(100, 'Done');
                        return; // Success!
                        
                    } else if (statusData.status === 'error') {
                        clearInterval(timerInterval);
                        throw new Error(statusData.error || 'Query processing failed');
                        
                    } else if (statusData.status === 'processing') {
                        setProgress(50, `Processing... (${elapsed}s elapsed)`);
                        // Continue polling
                    } else {
                        // pending - continue polling, but show elapsed if available
                        if (elapsed > 0) {
                            setProgress(45, `Waiting to start... (${elapsed}s elapsed)`);
                        } else {
                            setProgress(45, 'Waiting to start...');
                        }
                    }
                }
                
                clearInterval(timerInterval);
                
                // Timeout after max polls
                throw new Error('Query is taking too long. Please try again or simplify your question.');
                
            } catch (error) {
                // Clear timer on error (timerInterval is in outer scope)
                if (timerInterval) {
                    clearInterval(timerInterval);
                }
                // Google principle #8: Make errors recoverable, not punishing
                // Preserve the query in the input field so user can try again
                let errorMsg = error.message;
                let reqId = 'n/a';
                
                // Try to get Request ID from response if available (for non-timeout errors)
                try {
                    if (error.response && error.response.headers) {
                        reqId = error.response.headers.get('X-Request-ID') || 'n/a';
                    }
                } catch (e) {
                    // Response not available (timeout case)
                }
                
                if (error.name === 'AbortError' || errorMsg.includes('aborted')) {
                    // Timeout - check server logs via /status endpoint to get recent Request IDs
                    errorMsg = '⚠️ Query timed out (took longer than 7 minutes).\n\n' +
                               'Your question is still in the box above - try simplifying it or breaking it into smaller parts.\n\n' +
                               'Check server console logs for Request ID, or visit http://localhost:8000/status to see recent requests.';
                } else if (errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError')) {
                    // Try to check if server is running (async check)
                    const checkServer = async () => {
                        try {
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 2000);
                            const healthCheck = await fetch('http://localhost:8000/health', { 
                                method: 'GET',
                                signal: controller.signal
                            });
                            clearTimeout(timeoutId);
                            if (healthCheck.ok) {
                                // Server is running - likely a timeout or processing issue
                                return '⚠️ Connection lost. The query might be taking too long (large queries take 30-90 seconds).\n\n' +
                                       'Your question is still in the box above - just click "Ask Thunderclap" to try again, or simplify your question.\n\n' +
                                       'Check server console logs for Request ID, or visit http://localhost:8000/status to see recent requests.';
                            }
                        } catch (e) {
                            // Server is not running or not accessible
                            return '⚠️ Server is not running.\n\n' +
                                   'Please start the server by running: python server.py\n\n' +
                                   'Then try your query again.';
                        }
                        return '⚠️ Connection lost. Please check if the server is running: python server.py';
                    };
                    
                    // Show checking message immediately, then update when check completes
                    errorMsg = '⚠️ Connection lost. Checking server status...';
                    document.getElementById('answer').innerHTML = `<p style="white-space: pre-line; line-height: 1.8;">${errorMsg}</p>`;
                    checkServer().then(msg => {
                        document.getElementById('answer').innerHTML = `<p style="white-space: pre-line; line-height: 1.8;">${msg}</p>`;
                    }).catch(() => {
                        // If check fails, show server not running message
                        document.getElementById('answer').innerHTML = `<p style="white-space: pre-line; line-height: 1.8;">⚠️ Server is not running.\n\nPlease start the server by running: python server.py\n\nThen try your query again.</p>`;
                    });
                    // Skip default error display - we handle it above with async check
                    document.getElementById('suggested-questions-container').style.display = 'none';
                    document.getElementById('result').classList.add('show', 'error');
                    return; // Exit early to prevent default error display below
                } else if (errorMsg.includes('Token quota') || errorMsg.includes('token quota') || errorMsg.includes('250,000 tokens')) {
                    errorMsg = '⚠️ Token quota exceeded (250,000 tokens/minute). Your query uses too many tokens.\n\n' +
                               'Please wait 1-2 minutes and try again, or simplify your question to use fewer chunks.\n\n' +
                               'Your question is preserved above - just click "Ask Thunderclap" when ready.';
                } else if (errorMsg.includes('quota exhausted') || (errorMsg.includes('quota') && errorMsg.includes('exhausted') && errorMsg.includes('daily'))) {
                    errorMsg = '⚠️ API daily quota exhausted. Please wait and try again later, or check your API quota limits.\n\n' +
                               'Your question is preserved above - just click "Ask Thunderclap" when ready.';
                } else if (errorMsg.includes('rate limit') || errorMsg.includes('429') || (errorMsg.includes('quota') && !errorMsg.includes('exhausted'))) {
                    errorMsg = '⚠️ API rate limit reached. Please wait 30-60 seconds and try again.\n\n' +
                               'Your question is preserved above - just click "Ask Thunderclap" when ready.';
                } else {
                    errorMsg = '⚠️ Something went wrong: ' + errorMsg + '\n\nYour question is preserved - try clicking "Ask Thunderclap" again.';
                    if (reqId !== 'n/a') {
                        errorMsg += '\n\nRequest ID: ' + reqId;
                    }
                }
                document.getElementById('answer').innerHTML = `<p style="white-space: pre-line; line-height: 1.8;">${errorMsg}</p>`;
                document.getElementById('suggested-questions-container').style.display = 'none';
                document.getElementById('result').classList.add('show', 'error');
            } finally {
                // Clear progress timeout and hide loading
                clearTimeout(progressTimeout);
                while (bumps.length) clearTimeout(bumps.pop());
                document.getElementById('loading').classList.remove('show');
                // Reset progress UI after a short delay
                setTimeout(() => {
                    setProgress(0, 'Analyzing your query...');
                    document.getElementById('progress-container').style.display = 'none';
                }, 600);
                document.querySelector('button').disabled = false;
            }
        }
        
        // Progress helpers
        function setProgress(percent, text) {
            const bar = document.getElementById('progress-bar');
            if (!bar) return;
            const p = Math.max(0, Math.min(100, percent));
            bar.style.width = p + '%';
            if (text) {
                const details = document.getElementById('loading-details');
                if (details) details.textContent = text;
            }
        }
        function bumpProgress(delta) {
            const bar = document.getElementById('progress-bar');
            if (!bar) return;
            const current = parseInt(bar.style.width || '0', 10) || 0;
            setProgress(Math.min(95, current + delta));
        }
        
        // Allow Enter key to submit
        document.getElementById('question').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                askQuestion();
            }
        });
    </script>
</body>
</html>

