<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Version: 2025-01-22-17:45 - Platinum Theme v7 - BUILD: e7d79db -->
    <meta name="build-id" content="e7d79db-2025-01-22-17:45-platinum">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Thunderclap AI - Banking History</title>
    <script>
        // Cache busting - check version but don't block execution
        (function() {
            const CURRENT_VERSION = '7';
            const BUILD_ID = 'e7d79db-2025-01-22-17:45-platinum';
            const urlParams = new URLSearchParams(window.location.search);
            const currentVersion = urlParams.get('v');
            
            // Check if build ID matches
            const metaBuildId = document.querySelector('meta[name="build-id"]')?.content;
            if (metaBuildId && metaBuildId !== BUILD_ID) {
                console.warn('⚠️ Build ID mismatch! Expected:', BUILD_ID, 'Got:', metaBuildId);
            }
            
            // If version doesn't match or missing, force reload (but only once to avoid loops)
            if (currentVersion !== CURRENT_VERSION && !sessionStorage.getItem('version-check-done')) {
                sessionStorage.setItem('version-check-done', 'true');
                urlParams.set('v', CURRENT_VERSION);
                urlParams.set('_t', Date.now());
                const newUrl = window.location.pathname + '?' + urlParams.toString() + window.location.hash;
                console.log('Cache bust: redirecting to', newUrl);
                window.location.replace(newUrl);
                return; // Stop execution
            }
            
            // Version matches - log for debugging
            console.log('✅ Running version', CURRENT_VERSION, 'Build:', BUILD_ID, '- All features enabled');
            window.THUNDERCLAP_VERSION = CURRENT_VERSION;
            window.THUNDERCLAP_BUILD = BUILD_ID;
        })();
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #E5E4E2 0%, #C0C0C0 50%, #A8A8A8 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
            flex-direction: row;
            justify-content: space-between;
        }
        .brand-text { display: flex; flex-direction: column; }
        .brand img.logo {
            width: 176px;
            height: 176px;
            object-fit: contain;
            image-rendering: -webkit-optimize-contrast;
        }
        .brand h1 { color: #C0C0C0; }
        
        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 800px;
            width: 100%;
            padding: 40px;
        }
        
        /* Mobile optimization - Google principle #6 */
        @media (max-width: 768px) {
            body {
                padding: 10px;
                align-items: flex-start;
                padding-top: 20px;
            }
            
            .container {
                padding: 20px;
                border-radius: 15px;
            }
            
            h1 {
                font-size: 1.8em !important;
            }
            
            input[type="text"] {
                font-size: 16px !important; /* Prevents iOS zoom */
            }
            
            button {
                padding: 18px !important; /* Thumb-friendly tap target */
                font-size: 1.05em !important;
            }
            
            .suggested-questions li {
                padding: 15px !important; /* Larger tap targets */
            }
        }
        
        h1 {
            color: #C0C0C0;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            transition: border 0.3s;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: #C0C0C0;
        }
        
        button {
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
            background: linear-gradient(135deg, #D3D3D3 0%, #A8A8A8 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .result {
            margin-top: 30px;
            padding: 30px;
            background: #ffffff;
            border-radius: 15px;
            border: 2px solid #e8e8e8;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            display: none;
        }
        
        .result.show {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Tab system styles */
        .tabs-container {
            margin-bottom: 20px;
            border-bottom: 2px solid #e8e8e8;
        }
        
        .tabs-bar {
            display: flex;
            gap: 5px;
            overflow-x: auto;
            padding-bottom: 5px;
        }
        
        .tabs-bar::-webkit-scrollbar {
            height: 6px;
        }
        
        .tabs-bar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        .tabs-bar::-webkit-scrollbar-thumb {
            background: #C0C0C0;
            border-radius: 3px;
        }
        
        .tab {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: #f5f5f5;
            border: 1px solid #e0e0e0;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            min-width: 100px;
            max-width: 300px;
        }
        
        .tab:hover {
            background: #e8e8e8;
        }
        
        .tab.active {
            background: #fff;
            border-bottom: 2px solid #fff;
            border-color: #C0C0C0;
            color: #C0C0C0;
            font-weight: 600;
            margin-bottom: -2px;
        }
        
        .tab-title {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .tab-close {
            font-size: 18px;
            line-height: 1;
            color: #999;
            cursor: pointer;
            padding: 0 5px;
            transition: color 0.2s;
        }
        
        .tab-close:hover {
            color: #C0C0C0;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .tab-content p {
            margin-bottom: 1.2em;
            line-height: 1.8;
        }
        
        .tab-content p:last-child {
            margin-bottom: 0;
        }
        
        .result h2 {
            color: #C0C0C0;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 10px;
        }
        
        #answer {
            color: #333;
            line-height: 1.8;
            font-size: 1.05em;
        }
        
        #answer h2 {
            color: #C0C0C0;
            margin-top: 25px;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.5em;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 8px;
        }
        
        #answer h3 {
            color: #555;
            font-size: 1.2em;
            margin-top: 20px;
            margin-bottom: 12px;
            font-weight: 600;
        }
        
        #answer p {
            margin-bottom: 15px;
            line-height: 1.8;
        }
        
        #answer strong {
            color: #333;
            font-weight: 600;
        }
        
        #answer em {
            font-style: italic;
            color: #555;
        }
        
        .suggested-questions {
            margin-top: 30px;
            padding: 25px;
            background: #fbf3cf;
            border-radius: 12px;
            border-left: 4px solid #C0C0C0;
        }
        
        .suggested-questions h3 {
            color: #C0C0C0;
            font-size: 1.2em;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .suggested-questions ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .suggested-questions li {
            padding: 12px 15px;
            margin-bottom: 10px;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
            font-size: 0.95em;
        }
        
        .suggested-questions li:before {
            content: "→ ";
            color: #C0C0C0;
            font-weight: bold;
            margin-right: 5px;
        }
        
        .suggested-questions li:hover {
            background: #C0C0C0;
            color: white;
            transform: translateX(5px);
            border-color: #C0C0C0;
        }
        
        .suggested-questions li:hover:before {
            color: white;
        }
        
        .loading {
            text-align: center;
            padding: 30px;
            display: none;
        }
        
        .loading.show {
            display: block;
        }
        
        .loading-details {
            margin-top: 15px;
            color: #C0C0C0;
            font-size: 0.95em;
            line-height: 1.6;
        }
        
        .loading-tip {
            margin-top: 10px;
            color: #888;
            font-size: 0.85em;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #C0C0C0;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error {
            background: #fee;
            border-left-color: #f44336;
        }
        
        .attribution {
            text-align: center;
            margin-top: 20px;
            color: #999;
            font-size: 0.9em;
        }
        
        .search-guide {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .search-guide h3 {
            margin-top: 0;
            color: #333;
            font-size: 1.15em;
        }
        
        .search-guide p {
            margin-top: 6px;
            color: #666;
            font-size: 0.9em;
        }
        
        .search-categories {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }
        
        .quick-query {
            background: white;
            border: 2px solid #D3D3D3;
            color: #5a4a12;
            padding: 10px 14px;
            border-radius: 999px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        
        .quick-query:hover {
            border-color: #C0C0C0;
            color: #C0C0C0;
            transform: translateY(-2px);
        }
        
        .secondary-btn {
            width: 100%;
            padding: 12px;
            font-size: 1em;
            background: white;
            color: #C0C0C0;
            border: 2px solid #C0C0C0;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            margin-top: 10px;
        }
        
        .secondary-btn:hover {
            background: #C0C0C0;
            color: white;
        }
        
    </style>
</head>
<body>
    <div class="container">
        <div class="brand">
            <div class="brand-text">
                <h1>Thunderclap AI</h1>
                <p class="subtitle">Banking through panics, kin, and shifting identities.</p>
            </div>
            <img class="logo" src="./public/img/thunderclap_emblem.png?v=2" alt="Thunderclap emblem" onerror="this.style.display='none';" />
        </div>
        
        <div class="search-guide">
            <p style="margin-bottom: 15px; color: #555;">Use the search box below or open the sampler to pick a topic.</p>
            <button class="secondary-btn" id="view-sample-terms-btn">View Sample Terms</button>
        </div>
        
        <div class="input-group">
            <input 
                type="text" 
                id="question" 
                placeholder="Ask about families, panics, identities, or institutions..."
                maxlength="500"
            >
        </div>
        
        <button id="ask-thunderclap-btn">Ask Thunderclap</button>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p style="margin-top: 10px; color: #C0C0C0; font-weight: 600;">Researching historical documents...</p>
            <div class="loading-details" id="loading-details">
                Analyzing your query...
            </div>
            <div id="progress-container" style="margin-top:12px; width:100%; background:#eee; border-radius:8px; overflow:hidden; height:10px; display:none;">
                <div id="progress-bar" style="height:100%; width:0%; background:#C0C0C0; transition: width 0.3s ease;"></div>
            </div>
            <div class="loading-tip" id="loading-tip" style="display: block; visibility: visible; opacity: 1;">
                ⏱️ <span id="time-estimate">Estimating time...</span> | <span id="elapsed-timer">0s</span>
            </div>
        </div>
        
        <div class="result" id="result">
            <div class="tabs-container" id="tabs-container" style="display: none;">
                <div class="tabs-bar" id="tabs-bar"></div>
            </div>
            <div id="tabs-content"></div>
        </div>
        
        <div class="attribution">
            Powered by Thunderclap AI | Data protected and secure
        </div>
    </div>

    <script>
        // Tab management system
        let tabs = [];
        let activeTabId = null;
        let tabCounter = 0;
        
        function createTab(question, jobId) {
            const tabId = `tab-${++tabCounter}`;
            const tab = {
                id: tabId,
                question: question,
                jobId: jobId,
                answer: null,
                questions: [],
                error: null,
                status: 'loading',
                createdAt: Date.now()
            };
            tabs.push(tab);
            activeTabId = tabId;
            console.log('Created tab:', tabId, 'Total tabs:', tabs.length);
            renderTabs();
            renderTabContent();
            return tabId;
        }
        
        function closeTab(tabId, event) {
            if (event) {
                event.stopPropagation();
            }
            tabs = tabs.filter(t => t.id !== tabId);
            if (activeTabId === tabId) {
                activeTabId = tabs.length > 0 ? tabs[tabs.length - 1].id : null;
            }
            renderTabs();
            renderTabContent();
        }
        
        function switchTab(tabId) {
            activeTabId = tabId;
            renderTabs();
            renderTabContent();
        }
        
        function updateTab(tabId, updates) {
            const tab = tabs.find(t => t.id === tabId);
            if (tab) {
                Object.assign(tab, updates);
                renderTabs();
                if (activeTabId === tabId) {
                    renderTabContent();
                }
            }
        }
        
        function renderTabs() {
            const container = document.getElementById('tabs-container');
            const tabsBar = document.getElementById('tabs-bar');
            
            if (!container || !tabsBar) {
                console.error('Tabs container or bar not found!');
                return;
            }
            
            if (tabs.length === 0) {
                container.style.display = 'none';
                return;
            }
            
            // Show container and ensure result div is visible
            container.style.display = 'block';
            const resultDiv = document.getElementById('result');
            if (resultDiv) {
                resultDiv.classList.add('show');
            }
            
            if (tabsBar) {
                tabsBar.innerHTML = '';
            }
            console.log('Rendering', tabs.length, 'tabs');
            
            tabs.forEach(tab => {
                const tabEl = document.createElement('div');
                tabEl.className = `tab ${tab.id === activeTabId ? 'active' : ''}`;
                tabEl.onclick = () => switchTab(tab.id);
                
                const title = document.createElement('span');
                title.className = 'tab-title';
                title.textContent = tab.question.length > 30 ? tab.question.substring(0, 30) + '...' : tab.question;
                title.title = tab.question;
                
                const close = document.createElement('span');
                close.className = 'tab-close';
                close.innerHTML = '×';
                close.onclick = (e) => closeTab(tab.id, e);
                
                tabEl.appendChild(title);
                tabEl.appendChild(close);
                tabsBar.appendChild(tabEl);
            });
        }
        
        function renderTabContent() {
            const contentContainer = document.getElementById('tabs-content');
            if (!contentContainer) {
                console.error('Tabs content container not found!');
                return;
            }
            
            contentContainer.innerHTML = '';
            
            if (!activeTabId) {
                return;
            }
            
            const tab = tabs.find(t => t.id === activeTabId);
            if (!tab) {
                return;
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'tab-content active';
            contentDiv.id = `tab-content-${tab.id}`;
            
            if (tab.status === 'loading') {
                contentDiv.innerHTML = '<p style="color: #666; padding: 20px; text-align: center;">Loading...</p>';
            } else if (tab.error) {
                contentDiv.innerHTML = `<p style="white-space: pre-line; line-height: 1.8;">${tab.error}</p>`;
            } else if (tab.answer) {
                const answerDiv = document.createElement('div');
                answerDiv.innerHTML = formatMarkdown(tab.answer);
                contentDiv.appendChild(answerDiv);
                
                if (tab.questions && tab.questions.length > 0) {
                    const questionsContainer = document.createElement('div');
                    questionsContainer.id = `suggested-questions-${tab.id}`;
                    displaySuggestedQuestions(tab.questions, questionsContainer);
                    contentDiv.appendChild(questionsContainer);
                }
            }
            
            // Add debug info if available
            if (tab.jobId) {
                const debugDiv = document.createElement('div');
                debugDiv.style.marginTop = '12px';
                debugDiv.style.fontSize = '0.85em';
                debugDiv.style.color = '#666';
                debugDiv.innerHTML = `
                    <div>Request ID: ${tab.jobId}</div>
                    <div><a href="http://localhost:8000/debug/last?n=50" target="_blank" style="color:#C0C0C0;">View server trace</a></div>
                `;
                contentDiv.appendChild(debugDiv);
            }
            
            contentContainer.appendChild(contentDiv);
        }
        
        // IMPORTANT: Change this to your deployed API URL
        // API URL - defaults to localhost, but can be overridden via URL parameter or environment
        const API_URL = (() => {
            const urlParams = new URLSearchParams(window.location.search);
            const apiParam = urlParams.get('api');
            if (apiParam) return apiParam;
            // If on GitHub Pages, use Railway server
            if (window.location.hostname.includes('github.io')) {
                return 'https://web-production-c4223.up.railway.app/query';
            }
            // Default to localhost for local development
            return 'http://localhost:8000/query';
        })();
        
        function fillExample(text) {
            document.getElementById('question').value = text;
        }
        
        function extractSuggestedQuestions(text) {
            // Extract suggested questions section - match all common variations
            const patterns = [
                /Related Questions:\s*([\s\S]*?)$/i,  // Check this first - most common format
                /\*\*Related Questions:\*\*\s*([\s\S]*?)$/i,
                /Here are some potential follow-up questions.*?:\s*([\s\S]*?)$/i,
                /Potential follow-up questions.*?:\s*([\s\S]*?)$/i,
                /Follow-up questions.*?:\s*([\s\S]*?)$/i,
                /\*\*Suggested Questions:\*\*\s*([\s\S]*?)$/i,
                /Suggested Questions:\s*([\s\S]*?)$/i,
                /\*\*Questions for further exploration:\*\*\s*([\s\S]*?)$/i
            ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    const questionsSection = match[1];
                    const questions = [];
                    
                    // First: Parse line by line - this handles bullet format correctly
                    // Format: "* Question 1?\n* Question 2?\n* Question 3?"
                    const lines = questionsSection.split('\n');
                    const lineMatches = [];
                    for (const line of lines) {
                        const trimmed = line.trim();
                        // Match bullet format: "* Question?" or "- Question?" or "• Question?"
                        const bulletMatch = trimmed.match(/^[-•→*]\s*(.+)$/);
                        if (bulletMatch) {
                            const q = bulletMatch[1].trim();
                            if (q.length > 10 && q.endsWith('?')) {
                                lineMatches.push(q);
                            }
                        } else if (trimmed.length > 10 && trimmed.endsWith('?') && !trimmed.match(/^\d+\./)) {
                            // Standalone question without bullet
                            lineMatches.push(trimmed);
                        }
                    }
                    if (lineMatches.length > 0) {
                        const cleanText = text.substring(0, match.index).trim();
                        console.log('[EXTRACT] Found', lineMatches.length, 'questions from line-by-line parsing:', lineMatches);
                        return { text: cleanText, questions: lineMatches };
                    }
                    
                    // Fallback: Also try: Questions on same line separated by multiple spaces and asterisks
                    // Pattern: "Question1*   Question2*   Question3?"
                    const inlineAsteriskPattern = /([^*?]+(?:[?]|Tell me|What|Who|How|When|Where|Why)[^*]*)/gi;
                    const inlineMatches = [];
                    let inlineMatch;
                    while ((inlineMatch = inlineAsteriskPattern.exec(questionsSection)) !== null) {
                        const q = inlineMatch[1].trim();
                        if (q.length > 10) {
                            inlineMatches.push(q);
                        }
                    }
                    if (inlineMatches.length > 1) {
                        const cleanText = text.substring(0, match.index).trim();
                        return { text: cleanText, questions: inlineMatches };
                    }
                    
                    // Second try: Extract questions from lines (numbers or bullets)
                    // First, normalize the text - handle cases where questions are split incorrectly
                    // CRITICAL: Handle questions concatenated on one line: "Boston?2. How did..." -> "Boston?\n2. How did..."
                    // Split BEFORE the number pattern, not after the question mark
                    let normalizedSection = questionsSection;
                    // Pattern: question mark followed immediately by number: "?2." -> "?\n2."
                    normalizedSection = normalizedSection.replace(/([?])(\d+)\./g, '$1\n$2.');
                    // Pattern: question mark, space(s), then number: "? 2." -> "?\n2."
                    normalizedSection = normalizedSection.replace(/([?])\s+(\d+)\./g, '$1\n$2.');
                    // Pattern: Handle concatenated questions like "RR contribute to the Panic of 1901?3. What actions did"
                    // Split on number pattern even if it comes after a question mark on same line
                    normalizedSection = normalizedSection.replace(/([?])(\d+)\./g, '$1\n$2.');
                    // Also handle if questions are on same line without question marks: "Boston.2. How..." -> "Boston.\n2. How..."
                    // But only if preceded by a word (not already a number)
                    normalizedSection = normalizedSection.replace(/([a-zA-Z])(\d+)\./g, '$1\n$2.');
                    // CRITICAL: Also handle bullets that might be concatenated: "* Question 1?* Question 2?" -> "* Question 1?\n* Question 2?"
                    normalizedSection = normalizedSection.replace(/([?])\s*(\*)/g, '$1\n$2');
                    // Handle bullets without question marks: "Question 1* Question 2" -> "Question 1\n* Question 2"
                    normalizedSection = normalizedSection.replace(/([a-zA-Z])\s*(\*)/g, '$1\n$2');
                    
                    // CRITICAL: Handle incomplete questions that start mid-sentence
                    // If a line doesn't start with a number, bullet, or question word, it's likely a continuation or incomplete
                    // Check if first "question" starts mid-sentence and remove it
                    const firstLine = normalizedSection.split('\n')[0]?.trim() || '';
                    const questionStartPattern = /^(What|Who|How|When|Where|Why|Tell me|Describe|Explain|\d+\.|[-•→*])/i;
                    if (firstLine && !questionStartPattern.test(firstLine) && firstLine.length > 0) {
                        // First line is incomplete - remove it and everything before the first numbered/bulleted question
                        const firstNumberMatch = normalizedSection.match(/(\d+\.)/);
                        const firstBulletMatch = normalizedSection.match(/^[-•→*]/m);
                        if (firstNumberMatch && firstBulletMatch) {
                            // Use whichever comes first
                            const numberIndex = normalizedSection.indexOf(firstNumberMatch[0]);
                            const bulletIndex = normalizedSection.indexOf(firstBulletMatch[0]);
                            const firstIndex = Math.min(numberIndex, bulletIndex);
                            normalizedSection = normalizedSection.substring(firstIndex);
                        } else if (firstNumberMatch) {
                            const firstNumberIndex = normalizedSection.indexOf(firstNumberMatch[0]);
                            normalizedSection = normalizedSection.substring(firstNumberIndex);
                        } else if (firstBulletMatch) {
                            const firstBulletIndex = normalizedSection.indexOf(firstBulletMatch[0]);
                            normalizedSection = normalizedSection.substring(firstBulletIndex);
                        }
                    }
                    
                    // Fallback: If still all on one line, try splitting by number pattern directly
                    // This handles cases like "1. Question?2. Question?3. Question?"
                    if (!normalizedSection.includes('\n') && normalizedSection.match(/\d+\./)) {
                        // Split on number pattern but keep the number with the question
                        normalizedSection = normalizedSection.replace(/(\d+)\./g, '\n$1.');
                        // Remove leading newline
                        normalizedSection = normalizedSection.replace(/^\n+/, '');
                    }
                    
                    const normalizedLines = normalizedSection.split('\n');
                    let currentQuestion = '';
                    
                    for (let i = 0; i < normalizedLines.length; i++) {
                        const line = normalizedLines[i].trim();
                        if (!line) {
                            // Empty line - if we have a current question, save it
                            if (currentQuestion && currentQuestion.length > 10) {
                                questions.push(currentQuestion.trim());
                                currentQuestion = '';
                            }
                            continue;
                        }
                        
                        // Check if this line starts a new numbered question (e.g., "2. How did...")
                        const numberMatch = line.match(/^(\d+)\.\s*(.+)$/);
                        if (numberMatch) {
                            // Save previous question if we have one
                            if (currentQuestion && currentQuestion.length > 10) {
                                questions.push(currentQuestion.trim());
                            }
                            // Start new question
                            currentQuestion = numberMatch[2];
                        }
                        // Check if this line starts a bullet question (e.g., "* Question?" or "- Question?")
                        else if (line.match(/^[-•→*]\s*(.+)$/)) {
                            const bulletMatch = line.match(/^[-•→*]\s*(.+)$/);
                            if (bulletMatch) {
                                // Save previous question if we have one
                                if (currentQuestion && currentQuestion.length > 10) {
                                    questions.push(currentQuestion.trim());
                                }
                                // Start new question
                                currentQuestion = bulletMatch[1];
                            }
                        }
                        // If we're building a question, continue appending to it
                        else if (currentQuestion) {
                            // Append to current question (handles multi-line questions)
                            // But stop if we hit a new question marker
                            if (line.match(/^\d+\./)) {
                                // This is a new numbered question - save current and start new
                                if (currentQuestion.length > 10) {
                                    questions.push(currentQuestion.trim());
                                }
                                const newMatch = line.match(/^\d+\.\s*(.+)$/);
                                currentQuestion = newMatch ? newMatch[1] : '';
                            } else if (line.match(/^[-•→*]\s*(.+)$/)) {
                                // This is a new bullet question - save current and start new
                                if (currentQuestion.length > 10) {
                                    questions.push(currentQuestion.trim());
                                }
                                const bulletMatch = line.match(/^[-•→*]\s*(.+)$/);
                                currentQuestion = bulletMatch ? bulletMatch[1] : '';
                            } else {
                                currentQuestion += ' ' + line;
                            }
                        }
                        // Standalone question ending with ?
                        else if (line.length > 10 && line.endsWith('?') && !line.match(/^\d+\./)) {
                            questions.push(line);
                        }
                    }
                    
                    // Don't forget the last question
                    if (currentQuestion && currentQuestion.length > 10) {
                        questions.push(currentQuestion.trim());
                    }
                    
                    // Basic validation - filter incomplete questions
                    // The LLM should generate complete questions, but we catch incomplete ones
                    console.log('[EXTRACT] Raw questions before filtering:', questions);
                    questions = questions.filter(q => {
                        const cleaned = q.trim();
                        // Remove questions that are just numbers or very short (relaxed from 15 to 10)
                        if (cleaned.length < 10) {
                            console.log('[FILTER] Too short:', cleaned);
                            return false;
                        }
                        // Remove questions that are just fragments
                        if (cleaned.match(/^[\d\s\.\?]+$/)) return false;
                        // CRITICAL: Filter incomplete questions FIRST (before checking for question mark)
                        // Check for questions ending with incomplete prepositions/verbs (with or without question mark)
                        const incompleteEndings = /\b(between|affect|surrounding|involving|regarding|concerning|about|with|for|to|from|of|in|on|at|by|during|through|across|among|within|without|against|toward|towards|into|onto|upon|under|over|above|below|beside|besides|beyond|behind|before|after|since|until|while)\s*\?*$/i;
                        if (incompleteEndings.test(cleaned)) {
                            console.warn('Incomplete question detected (ends with preposition/verb):', cleaned);
                            return false;
                        }
                        // CRITICAL: Also check if question ends with "surrounding" or "between" even if it has a question mark
                        if (cleaned.match(/\b(surrounding|between|affect|involving)\s*\?$/i)) {
                            console.warn('Incomplete question detected (ends with verb/preposition + ?):', cleaned);
                            return false;
                        }
                        // CRITICAL: Questions should end with "?" but allow some flexibility
                        if (!cleaned.endsWith('?')) {
                            // Allow questions without ? if they're clearly questions (start with question word)
                            const isQuestionWord = /^(what|how|when|where|why|who|tell me|describe|explain)/i.test(cleaned);
                            if (!isQuestionWord) {
                                console.warn('Question missing question mark and not starting with question word:', cleaned);
                                return false;
                            }
                            // Add ? if missing
                            cleaned = cleaned + '?';
                        }
                        // Additional check: even with question mark, if it ends with a preposition, it's incomplete
                        const incompletePrepositions = /\b(between|affect|surrounding|involving|regarding|concerning|about|with|for|to|from|of|in|on|at|by|during|through|across|among|within|without|against|toward|towards|into|onto|upon|under|over|above|below|beside|besides|beyond|behind|before|after|since|until|while)\s*\?$/i;
                        if (incompletePrepositions.test(cleaned)) {
                            console.warn('Incomplete question detected (ends with preposition + ?):', cleaned);
                            return false;
                        }
                        // Check for questions that are clearly incomplete (very short after removing common question starters)
                        const questionStarters = /^(what|how|when|where|why|who|tell me|describe|explain)\s+/i;
                        if (questionStarters.test(cleaned)) {
                            const afterStarter = cleaned.replace(questionStarters, '').trim();
                            // If what remains is very short, it's likely incomplete
                            if (afterStarter.length < 20) {
                                console.warn('Incomplete question detected (too short after starter):', cleaned);
                                return false;
                            }
                            // If it ends with a preposition (with or without question mark), it's incomplete
                            if (incompleteEndings.test(afterStarter)) {
                                console.warn('Incomplete question detected (ends with preposition after starter):', cleaned);
                                return false;
                            }
                        }
                        return true;
                    }).map(q => {
                        // Ensure all questions end with ?
                        const cleaned = q.trim();
                        return cleaned.endsWith('?') ? cleaned : cleaned + '?';
                    });
                    
                    console.log('[EXTRACT] Questions after filtering:', questions.length, questions);
                    
                    if (questions.length > 0) {
                        // Remove the questions section from original text
                        const cleanText = text.substring(0, match.index).trim();
                        return { text: cleanText, questions: questions };
                    } else {
                        console.warn('[EXTRACT] Questions section found but all questions filtered out. Raw section:', questionsSection.substring(0, 200));
                    }
                }
            }
            
            // If no questions section found, check if answer ends with questions anyway
            console.log('[EXTRACT] No questions section pattern matched. Answer ends with:', text.substring(Math.max(0, text.length - 200)));
            return { text: text, questions: [] };
        }
        
        function displaySuggestedQuestions(questions, containerElement) {
            // Use provided container or fall back to default
            const container = containerElement || document.getElementById('suggested-questions-container');
            if (!container) {
                console.error('Suggested questions container not found!');
                return;
            }
            
            if (!questions || questions.length === 0) {
                container.style.display = 'none';
                return;
            }
            
            // Debug: log questions to console
            console.log('Extracted questions:', questions);
            console.log('Number of questions:', questions.length);
            
            // Build HTML with individual clickable items
            // Filter out incomplete questions one more time before display
            const validQuestions = questions.filter(q => {
                const cleaned = q.trim();
                // Must be at least 15 chars
                if (cleaned.length < 15) {
                    console.log('Filtered out (too short):', cleaned);
                    return false;
                }
                // Must start with question word or capital letter
                const questionStartPattern = /^(What|Who|How|When|Where|Why|Tell me|Describe|Explain|What was|What were|What is|What are|How did|How does|How do|When did|When does|Where did|Where does|Why did|Why does)/i;
                if (!questionStartPattern.test(cleaned) && !cleaned.match(/^[A-Z]/)) {
                    console.log('Filtered out (bad start):', cleaned);
                    return false;
                }
                // Must not end with incomplete words
                const incompletePattern = /\b(with|of|to|for|in|on|at|by|from|about|into|onto|upon|the|a|an)\s*$/i;
                if (incompletePattern.test(cleaned) && !cleaned.endsWith('?')) {
                    console.log('Filtered out (incomplete ending):', cleaned);
                    return false;
                }
                return true;
            });
            
            console.log('Valid questions after filtering:', validQuestions.length);
            console.log('Valid questions:', validQuestions);
            
            // CRITICAL: Filter out incomplete questions that end with prepositions/verbs
            const finalValidQuestions = validQuestions.filter(q => {
                const cleaned = q.trim();
                // Must end with "?"
                if (!cleaned.endsWith('?')) {
                    console.log('Filtered out (no question mark):', cleaned);
                    return false;
                }
                // Must not end with incomplete patterns
                const incompleteEndings = /\b(between|affect|surrounding|involving|regarding|concerning|about|with|for|to|from|of|in|on|at|by|during|through|across|among|within|without|against|toward|towards|into|onto|upon|under|over|above|below|beside|besides|beyond|behind|before|after|since|until|while)\s*\?$/i;
                if (incompleteEndings.test(cleaned)) {
                    console.log('Filtered out (incomplete ending):', cleaned);
                    return false;
                }
                // Must have substantial content after question word
                const questionStarters = /^(what|how|when|where|why|who|tell me|describe|explain)\s+/i;
                if (questionStarters.test(cleaned)) {
                    const afterStarter = cleaned.replace(questionStarters, '').trim();
                    if (afterStarter.length < 25) { // Increased minimum length
                        console.log('Filtered out (too short after starter):', cleaned);
                        return false;
                    }
                }
                return true;
            });
            
            console.log('Final valid questions after strict filtering:', finalValidQuestions.length);
            
            if (finalValidQuestions.length === 0) {
                console.warn('No valid questions after strict filtering!');
            }
            
            let html = '<div class="suggested-questions"><h3>Related Questions</h3><ul>';
            for (let i = 0; i < finalValidQuestions.length; i++) {
                const q = finalValidQuestions[i].trim();
                // Escape single quotes for onclick handler - use JSON.stringify for safer escaping
                const escaped = q.replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/\n/g, ' ').replace(/\r/g, '');
                // Escape HTML for display
                const displayText = q.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                html += `<li onclick="askSuggestedQuestion('${escaped}')">${displayText}</li>`;
            }
            html += '</ul></div>';
            
            if (!container) {
                console.error('Suggested questions container not found!');
                return;
            }
            
            try {
                container.innerHTML = html;
                container.style.display = 'block';
            } catch (e) {
                console.error('Error setting innerHTML on container:', e, 'Container:', container);
            }
        }
        
        function askSuggestedQuestion(question) {
            document.getElementById('question').value = question;
            askQuestion();
        }
        
        function formatMarkdown(text) {
            // Simple markdown-to-HTML converter
            let html = text;
            
            // Headers (do ## before # to avoid double-replacement)
            html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
            html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^# (.+)$/gm, '<h2>$1</h2>');  // Treat H1 as H2
            html = html.replace(/^\*\*(.+)\*\*$/gm, '<h3>$1</h3>');
            
            // Bold text
            html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            
            // Italic text (bank names)
            html = html.replace(/\*([^*]+?)\*/g, '<em>$1</em>');
            
            // Line breaks - preserve paragraph structure
            html = html.replace(/\n\n/g, '</p><p>');
            html = '<p>' + html + '</p>';
            
            // Clean up empty paragraphs and paragraphs around headers
            html = html.replace(/<p><\/p>/g, '');
            html = html.replace(/<p>\s*<\/p>/g, '');
            html = html.replace(/<p>(<h[123]>)/g, '$1');
            html = html.replace(/(<\/h[123]>)<\/p>/g, '$1');
            
            return html;
        }
        
        function selectIndexedQuery(query) {
            document.getElementById('question').value = query;
            const modal = document.getElementById('indexed-modal');
            if (modal) modal.remove();
        }

        
        
        function showIndexed() {
            const existingModal = document.getElementById('indexed-modal');
            if (existingModal) existingModal.remove();
            
            const chip = (label, prompt) => `<div class="quick-query" style="margin-bottom:8px;" onclick="selectIndexedQuery('${prompt.replace(/'/g, "\\'")}')">${label}</div>`;
            
            const families = [
                ["Rothschild Paris", "Tell me about Paris Rothschild banking"],
                ["Rothschild London", "Tell me about London Rothschild banking"],
                ["Rothschild Vienna", "Tell me about Vienna Rothschild banking"],
                ["Lazard Paris", "Tell me about Lazard Paris banking"],
                ["Lazard London", "Tell me about Lazard London banking"],
                ["Lazard New York", "Tell me about Lazard New York banking"],
                ["Morgan London", "Tell me about Morgan banking in London"],
                ["Morgan Paris", "Tell me about Morgan banking in Paris"],
                ["Morgan Grenfell", "Tell me about Morgan Grenfell"],
                ["Baring Brothers", "Tell me about Baring Brothers"],
                ["Hope & Co.", "Tell me about Hope banking"],
                ["Warburg Hamburg", "Tell me about the Warburgs in Hamburg"],
                ["Kuhn, Loeb & Co.", "Tell me about Kuhn, Loeb & Co. banking"],
                ["Jacob Schiff", "Tell me about Jacob Schiff"],
                ["Sassoon Bombay", "Tell me about the Sassoons in Bombay"],
                ["Sassoon Shanghai", "Tell me about the Sassoons in Shanghai"],
                ["Kadoorie Hong Kong", "Tell me about the Kadoories in Hong Kong"],
                ["Goldsmid London", "Tell me about Goldsmid bankers"],
                ["Hambro Copenhagen", "Tell me about Hambro bankers"],
                ["Montefiore London", "Tell me about Montefiore bankers"],
                ["Speyer Frankfurt", "Tell me about Speyer bankers"],
                ["Crédit Mobilier", "Tell me about Crédit Mobilier"],
                ["Crédit Lyonnais", "Tell me about Crédit Lyonnais"],
                ["Banque de France", "Tell me about Banque de France"],
                ["National City Bank", "Tell me about National City Bank"],
                ["First National Boston", "Tell me about First National Bank of Boston"],
                ["Bank of America", "Tell me about Bank of America"],
                ["Bank of Montreal", "Tell me about Bank of Montreal"],
                ["Hamburg-America finance", "Tell me about Hamburg-America finance"],
                ["Brown Brothers Harriman", "Tell me about Brown Brothers Harriman"],
                ["Federal Reserve System (FRS)", "Tell me about the Federal Reserve System (FRS)"],
                ["Federal Reserve Bank of New York (FRBNY)", "Tell me about the Federal Reserve Bank of New York (FRBNY)"],
                ["Bank of England (BOE)", "Tell me about the Bank of England (BOE)"],
                ["First Bank of the United States", "Tell me about the First Bank of the United States"],
                ["Second Bank of the United States", "Tell me about the Second Bank of the United States"],
                ["Reconstruction Finance Corporation (RFC)", "Tell me about the Reconstruction Finance Corporation (RFC)"],
                ["Securities and Exchange Commission (US SEC)", "Tell me about the United States Securities and Exchange Commission (SEC)"],
                ["War Finance Corporation", "Tell me about the War Finance Corporation"]
            ];
            
            const markets = [
                ["MMEU (Eurodollar) money market", "Tell me about the MMEU (Eurodollar) money market"],
                ["ABCP (asset-backed commercial paper)", "Tell me about asset-backed commercial paper (ABCP) conduits"],
                ["Long-term capital flows", "Tell me about long-term capital markets"],
                ["Eurodollar offshore deposits", "Tell me about the Eurodollar market (USD offshore)"],
                ["Sukarno-era Indonesian bonds", "Tell me about the Sukarno-era bond market"],
                ["Ottoman debt market", "Tell me about the Ottoman Empire's debt market"],
                ["Colonial silver trade", "Tell me about colonial-era silver markets"],
                ["Railroad securities", "Tell me about railroad securities trading"],
                ["Real estate trusts (REITs)", "Tell me about real estate finance (REITs)"],
                ["Conglomerate stocks", "Tell me about conglomerate equities"],
                ["Technology stocks", "Tell me about technology equities"],
                ["Slave finance markets", "Tell me about slave trading finance"],
                ["DEI investment programs", "Tell me about diversity finance initiatives"]
            ];
            
            const concepts = [
                ["Kinlinks in finance", "Tell me about kinlinks (family networks) in banking"],
                ["Minority middlemen", "Tell me about minority middlemen in finance"],
                ["Cousinhood marriages", "Tell me about cousinhood marriage networks"],
                ["Merchant diasporas", "Tell me about merchant diasporas in banking"],
                ["Cartelization", "Tell me about cartelization in banking"],
                ["Tax farming", "Tell me about tax farming in finance"],
                ["Courtier capitalism", "Tell me about courtier capitalism"],
                ["Socialism & banking", "Tell me about socialism's relationship with banking"],
                ["Marxism & capital", "Tell me about Marxist critiques of banking"],
                ["Nazism & banking", "Tell me about Nazi banking policies"],
                ["Command economies", "Tell me about command economies and finance"],
                ["Capitalism & free markets", "Tell me about capitalist/free-market banking"]
            ];
            
            const identities = [
                ["Sephardim", "Tell me about Sephardim"],
                ["Ashkenazim", "Tell me about Ashkenazim"],
                ["Court Jews", "Tell me about Court Jews"],
                ["Quakers", "Tell me about Quakers"],
                ["Huguenots", "Tell me about Huguenots"],
                ["Puritans", "Tell me about Puritans"],
                ["Greeks", "Tell me about Greeks"],
                ["Catholics", "Tell me about Catholics"],
                ["Templars", "Tell me about Templars"],
                ["Armenians", "Tell me about Armenians"],
                ["Parsees", "Tell me about Parsees"],
                ["Banias", "Tell me about Banias"],
                ["Dalits", "Tell me about Dalits"],
                ["Sunnis", "Tell me about Sunnis"],
                ["Old Believers", "Tell me about Old Believers"],
                ["Boston Brahmin", "Tell me about Boston Brahmin"],
                ["Knickerbockers", "Tell me about Knickerbockers"],
                ["Women", "Tell me about Women"],
                ["Blacks", "Tell me about Blacks"],
                ["Gays", "Tell me about Gays"],
                ["Hispanics", "Tell me about Hispanics"],
                ["Chinese", "Tell me about Chinese"],
                ["Japanese", "Tell me about Japanese"],
                ["Koreans", "Tell me about Koreans"]
            ];
            
            const panics = [
                "Panic of 1763","Panic of 1772","Panic of 1792","Panic of 1819",
                "Panic of 1825","Panic of 1837","Panic of 1847","Panic of 1857",
                "Panic of 1866","Panic of 1873","Panic of 1884","Panic of 1890",
                "Panic of 1893","Panic of 1896","Panic of 1901","Panic of 1907",
                "Panic of 1910","Panic of 1914","Panic of 1920","Panic of 1929",
                "Panic of 1931","Panic of 1973","Panic of 1987","Panic of 1997",
                "Panic of 1998","Panic of 2001","Panic of 2007","Panic of 2008"
            ];
            
            const geographies = [
                ["London", "Tell me about London banking"],
                ["Paris", "Tell me about Paris banking"],
                ["Frankfurt", "Tell me about Frankfurt banking"],
                ["Amsterdam", "Tell me about Amsterdam banking"],
                ["Vienna", "Tell me about Vienna banking"],
                ["Berlin", "Tell me about Berlin banking"],
                ["Moscow", "Tell me about Moscow banking"],
                ["New York", "Tell me about New York banking"],
                ["Boston", "Tell me about Boston banking"],
                ["Bombay", "Tell me about Bombay banking"],
                ["Calcutta", "Tell me about Calcutta banking"],
                ["Shanghai", "Tell me about Shanghai banking"],
                ["Hong Kong", "Tell me about Hong Kong banking"],
                ["Baghdad", "Tell me about Baghdad banking"],
                ["Cairo", "Tell me about Cairo banking"],
                ["Jerusalem", "Tell me about Jerusalem banking"],
                ["Philadelphia", "Tell me about Philadelphia banking"],
                ["Singapore", "Tell me about Singapore banking"],
                ["Ottoman Empire", "Tell me about Ottoman Empire banking"],
                ["British Empire", "Tell me about British imperial banking"],
                ["United Kingdom", "Tell me about British/UK banking"],
                ["United States", "Tell me about United States banking"],
                ["France", "Tell me about French banking"],
                ["Germany", "Tell me about German banking"],
                ["Netherlands", "Tell me about Dutch banking"],
                ["Italy", "Tell me about Italian banking"],
                ["Spain", "Tell me about Spanish banking"],
                ["Portugal", "Tell me about Portuguese banking"],
                ["Switzerland", "Tell me about Swiss banking"],
                ["Scandinavia", "Tell me about Scandinavian banking"],
                ["Russia", "Tell me about Russian banking"],
                ["India", "Tell me about Indian banking"],
                ["China", "Tell me about Chinese banking"],
                ["Japan", "Tell me about Japanese banking"],
                ["Southeast Asia", "Tell me about Southeast Asian banking"],
                ["Middle East", "Tell me about Middle Eastern banking"],
                ["North Africa", "Tell me about North African banking"],
                ["West Africa", "Tell me about West African banking"],
                ["Caribbean", "Tell me about Caribbean banking"],
                ["Latin America", "Tell me about Latin American banking"],
                ["Brazil", "Tell me about Brazilian banking"],
                ["Argentina", "Tell me about Argentine banking"]
            ];
            
            const renderChips = (items) => items.map(item => Array.isArray(item) ? chip(item[0], item[1]) : chip(item, `Tell me about ${item}`)).join('');
            
            const modal = `
                <div id="indexed-modal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 1000; display: flex; align-items: center; justify-content: center;" onclick="this.remove()">
                    <div style="background: white; padding: 30px; border-radius: 15px; max-width: 900px; max-height: 85vh; overflow-y: auto; border:2px solid #C0C0C0;" onclick="event.stopPropagation()">
                        <h2 style="color: #C0C0C0; margin-top: 0;">Sample Terms</h2>
                        <p style="color: #444; font-size: 0.95em; margin-bottom: 12px;">Tap any topic below to auto-fill the search bar, or type your own term.</p>
                        <p style="color: #777; font-size: 0.85em; margin-bottom: 18px;">
                            Showing highlighted topics. Type any other term directly in the search bar if you don’t see it listed here.
                        </p>
                        
                        <h3 style="color: #C0C0C0;">Banking Families & Houses</h3>
                        <div class="search-categories" style="margin-bottom: 15px;">
                            ${renderChips(families)}
                        </div>
                        
                        <h3 style="color: #C0C0C0;">Identities & Cousinhoods</h3>
                        <div class="search-categories" style="margin-bottom: 15px;">
                            ${renderChips(identities)}
                        </div>
                        
                        <h3 style="color: #C0C0C0;">Markets & Asset Classes</h3>
                        <div class="search-categories" style="margin-bottom: 15px;">
                            ${renderChips(markets)}
                        </div>
                        
                        <h3 style="color: #C0C0C0;">Concepts & Themes</h3>
                        <div class="search-categories" style="margin-bottom: 15px;">
                            ${renderChips(concepts)}
                        </div>
                        
                        <h3 style="color: #C0C0C0;">Financial Panics & Crises</h3>
                        <div class="search-categories" style="margin-bottom: 15px;">
                            ${renderChips(panics)}
                        </div>
                        
                        <h3 style="color: #C0C0C0;">Geographies</h3>
                        <div class="search-categories" style="margin-bottom: 15px;">
                            ${renderChips(geographies)}
                        </div>
                        
                        <button style="margin-top: 20px; padding: 10px 20px; background: linear-gradient(135deg, #D3D3D3 0%, #A8A8A8 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1em;" onclick="this.closest('div').parentElement.remove()">Close</button>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modal);
        }
        
        async function askQuestion() {
            console.log('askQuestion() called');
            const question = document.getElementById('question').value.trim();
            console.log('Question:', question);
            
            if (!question || question.length < 3) {
                alert('Please enter a question (at least 3 characters)');
                return;
            }
            
            // Show loading with progress updates (Google principle #5: Show progress and status)
            document.getElementById('loading').classList.add('show');
            // Ensure spinner and progress are visible
            document.getElementById('progress-container').style.display = 'block';
            setProgress(8, 'Starting...');
            document.getElementById('result').classList.add('show');
            document.querySelector('button').disabled = true;
            
            // Create new tab for this query
            let tabId = createTab(question, null);
            
            // Update loading message (simplified - timer/estimate shows in loading-tip)
            const loadingDetails = document.getElementById('loading-details');
            loadingDetails.textContent = 'Searching database...';
            
            // Initialize timer and estimate immediately
            const timerEl = document.getElementById('elapsed-timer');
            const estimateEl = document.getElementById('time-estimate');
            const loadingTip = document.getElementById('loading-tip');
            
            // Ensure loading-tip is visible and initialized (CRITICAL: Show immediately)
            if (loadingTip) {
                loadingTip.style.display = 'block';
                loadingTip.style.visibility = 'visible';
                loadingTip.style.opacity = '1';
            }
            if (timerEl) {
                timerEl.textContent = '0s';
            }
            if (estimateEl) {
                estimateEl.textContent = 'Estimating...';
            }
            
            // Start timer immediately (update every second)
            let timerStart = Date.now();
            let timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - timerStart) / 1000);
                if (timerEl) {
                    timerEl.textContent = `${elapsed}s`;
                }
            }, 1000);
            
            // Store interval so we can clear it later
            window.currentTimerInterval = timerInterval;
            
            setProgress(15, 'Collecting terms...');
            
            // Show progress update after 15 seconds
            const progressTimeout = setTimeout(() => {
                loadingDetails.textContent = 'Processing documents...';
                bumpProgress(10);
            }, 15000);
            // Gentle periodic bumps so users see progress
            const bumps = [];
            bumps.push(setTimeout(() => bumpProgress(10), 2500));
            bumps.push(setTimeout(() => bumpProgress(10), 6000));
            bumps.push(setTimeout(() => bumpProgress(10), 10000));
            bumps.push(setTimeout(() => bumpProgress(10), 20000));
            bumps.push(setTimeout(() => bumpProgress(10), 30000));
            
            async function fetchWithRetry(url, options, retries = 3, baseDelayMs = 800) {
                let attempt = 0;
                while (true) {
                    try {
                        const res = await fetch(url, options);
                        if (res.status === 429 || res.status === 502 || res.status === 503) {
                            if (attempt >= retries) return res;
                            const delay = baseDelayMs * Math.pow(2, attempt);
                            setProgress(Math.min(95, (attempt + 1) * 10 + 30), `Rate limit hit. Retrying in ${Math.ceil(delay/1000)}s...`);
                            await new Promise(r => setTimeout(r, delay));
                            attempt += 1;
                            continue;
                        }
                        return res;
                    } catch (e) {
                        if (attempt >= retries) throw e;
                        const delay = baseDelayMs * Math.pow(2, attempt);
                        setProgress(Math.min(95, (attempt + 1) * 10 + 30), `Network error. Retrying in ${Math.ceil(delay/1000)}s...`);
                        await new Promise(r => setTimeout(r, delay));
                        attempt += 1;
                    }
                }
            }
            
            try {
                setProgress(30, 'Starting query...');
                
                // Start background job - returns immediately to avoid Railway timeout
                let startResponse;
                try {
                    startResponse = await fetch(API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            question: question,
                            max_length: 15000
                        })
                    });
                } catch (fetchError) {
                    // Network error - server might be down or unreachable
                    throw new Error(`NETWORK ERROR: Cannot connect to server\n\nError: ${fetchError.message}\n\nAPI URL: ${API_URL}\n\nYour question is preserved above - fix the issue and try again.`);
                }
                
                if (!startResponse.ok) {
                    if (startResponse.status === 429) {
                        throw new Error('Rate limit exceeded. Please try again later.');
                    }
                    throw new Error('Failed to start query. HTTP ' + startResponse.status);
                }
                
                const jobData = await startResponse.json();
                const jobId = jobData.job_id;
                
                // Update tab with job ID
                updateTab(tabId, { jobId: jobId });
                
                setProgress(40, 'Processing query...');
                
                // Timer is already started above, just continue it
                // (timerInterval is already defined in outer scope)
                
                // Poll for completion every 2 seconds
                const pollInterval = 2000; // 2 seconds
                const maxPolls = 210; // 7 minutes max (210 * 2s = 420s)
                let pollCount = 0;
                
                // Function to calculate time estimate based on chunk count
                function calculateTimeEstimate(chunkCount) {
                    if (!chunkCount) return null;
                    
                    // Base time: 5-8 seconds for setup and retrieval
                    // Per chunk: ~2-3 seconds for LLM processing (varies with chunk size)
                    // More chunks = longer processing, but not strictly linear
                    const baseTime = 8;
                    const perChunkTime = chunkCount <= 20 ? 2.5 : (chunkCount <= 50 ? 2.0 : 1.8);
                    const estimatedSeconds = Math.ceil(baseTime + (chunkCount * perChunkTime));
                    
                    if (estimatedSeconds < 30) {
                        return `~${estimatedSeconds}s`;
                    } else if (estimatedSeconds < 60) {
                        return `~${estimatedSeconds}s`;
                    } else {
                        const minutes = Math.floor(estimatedSeconds / 60);
                        const seconds = estimatedSeconds % 60;
                        return seconds > 0 ? `~${minutes}m ${seconds}s` : `~${minutes}m`;
                    }
                }
                
                // Function to update time estimate display
                function updateTimeEstimate(chunkCount, elapsed) {
                    const estimateEl = document.getElementById('time-estimate');
                    if (!estimateEl) {
                        console.warn('[TIME] time-estimate element not found');
                        return;
                    }
                    
                    console.log('[TIME] updateTimeEstimate called:', { chunkCount, elapsed });
                    
                    const estimate = calculateTimeEstimate(chunkCount);
                    
                    if (chunkCount && estimate) {
                        estimateEl.textContent = `${chunkCount} chunks: ${estimate}`;
                        console.log('[TIME] Updated with chunk count:', estimateEl.textContent);
                    } else if (elapsed > 0) {
                        // Fallback estimate based on elapsed time
                        if (elapsed < 15) {
                            estimateEl.textContent = '~15-30s remaining';
                        } else if (elapsed < 45) {
                            estimateEl.textContent = '~30-60s remaining';
                        } else if (elapsed < 90) {
                            estimateEl.textContent = '~1-2min remaining';
                        } else {
                            estimateEl.textContent = '~2-3min remaining';
                        }
                        console.log('[TIME] Updated with elapsed time:', estimateEl.textContent);
                    } else {
                        // Even with no elapsed time, show initial estimate
                        estimateEl.textContent = '~15-30s';
                        console.log('[TIME] Set initial estimate:', estimateEl.textContent);
                    }
                }
                
                while (pollCount < maxPolls) {
                    await new Promise(r => setTimeout(r, pollInterval));
                    pollCount++;
                    
                    let statusResponse;
                    try {
                        statusResponse = await fetch(`${API_URL}/${jobId}`);
                    } catch (fetchError) {
                        if (timerInterval) clearInterval(timerInterval);
                        if (window.currentTimerInterval) clearInterval(window.currentTimerInterval);
                        // Network error - server might be down or unreachable
                        throw new Error(`NETWORK ERROR: Cannot connect to server. Error: ${fetchError.message}`);
                    }
                    if (!statusResponse.ok) {
                        if (timerInterval) clearInterval(timerInterval);
                        if (window.currentTimerInterval) clearInterval(window.currentTimerInterval);
                        throw new Error(`Failed to check status. HTTP ${statusResponse.status}`);
                    }
                    
                    const statusData = await statusResponse.json();
                    const elapsed = Math.floor(statusData.elapsed || 0);
                    
                    // Debug logging
                    console.log(`[POLL ${pollCount}] Status: ${statusData.status}, Elapsed: ${elapsed}s`);
                    
                    // Update time estimate - always update on every poll
                    // Use chunk_count if available, otherwise use elapsed time
                    if (statusData.chunk_count) {
                        updateTimeEstimate(statusData.chunk_count, elapsed);
                    } else {
                        // Update based on elapsed time (even if 0, show initial estimate)
                        updateTimeEstimate(null, elapsed);
                    }
                    
                    // Update loading details based on status
                    if (statusData.status === 'processing') {
                        loadingDetails.textContent = 'Generating answer...';
                    } else if (statusData.status === 'pending') {
                        loadingDetails.textContent = 'Preparing query...';
                    }
                    
                    if (statusData.status === 'complete') {
                        console.log('[SUCCESS] Query completed! Answer length:', statusData.answer?.length || 0);
                        if (timerInterval) clearInterval(timerInterval);
                        if (window.currentTimerInterval) clearInterval(window.currentTimerInterval);
                        setProgress(85, 'Formatting...');
                        
                        // Extract suggested questions
                        const parsed = extractSuggestedQuestions(statusData.answer);
                        console.log('[SUCCESS] Extracted answer and', parsed.questions?.length || 0, 'questions');
                        if (parsed.questions && parsed.questions.length > 0) {
                            console.log('[SUCCESS] Questions extracted:', parsed.questions);
                        } else {
                            console.warn('[WARNING] No questions extracted from answer. Answer length:', statusData.answer?.length || 0);
                            // Check if answer contains "Related Questions" section
                            if (statusData.answer && statusData.answer.includes('Related Questions')) {
                                console.warn('[WARNING] Answer contains "Related Questions" but extraction failed');
                            }
                        }
                        
                        // Update tab with results
                        updateTab(tabId, {
                            answer: parsed.text,
                            questions: parsed.questions,
                            status: 'complete',
                            error: null
                        });
                        
                        console.log('[SUCCESS] Tab updated, showing results');
                        document.getElementById('result').classList.add('show');
                        document.getElementById('result').classList.remove('error');
                        setProgress(100, 'Done');
                        return; // Success!
                        
                    } else if (statusData.status === 'error') {
                        if (timerInterval) clearInterval(timerInterval);
                        if (window.currentTimerInterval) clearInterval(window.currentTimerInterval);
                        
                        // Update tab with error
                        updateTab(tabId, {
                            status: 'error',
                            error: statusData.error || 'Query processing failed'
                        });
                        
                        throw new Error(statusData.error || 'Query processing failed');
                        
                    } else if (statusData.status === 'processing') {
                        setProgress(50, `Processing... (${elapsed}s elapsed)`);
                        // Continue polling
                    } else {
                        // pending - continue polling, but show elapsed if available
                        if (elapsed > 0) {
                            setProgress(45, `Waiting to start... (${elapsed}s elapsed)`);
                        } else {
                            setProgress(45, 'Waiting to start...');
                        }
                    }
                }
                
                if (timerInterval) clearInterval(timerInterval);
                if (window.currentTimerInterval) clearInterval(window.currentTimerInterval);
                
                // Timeout after max polls
                throw new Error('Query is taking too long. Please try again or simplify your question.');
                
            } catch (error) {
                console.error('Error in askQuestion:', error);
                // Clear timer on error (timerInterval is in outer scope)
                if (typeof timerInterval !== 'undefined' && timerInterval) {
                    clearInterval(timerInterval);
                }
                if (window.currentTimerInterval) {
                    clearInterval(window.currentTimerInterval);
                }
                // Google principle #8: Make errors recoverable, not punishing
                // Update tab with error (if tab exists)
                if (typeof tabId !== 'undefined' && tabId) {
                    updateTab(tabId, {
                        status: 'error',
                        error: error.message
                    });
                }
                
                // Preserve the query in the input field so user can try again
                let errorMsg = error.message;
                let reqId = 'n/a';
                
                // Try to get Request ID from response if available (for non-timeout errors)
                try {
                    if (error.response && error.response.headers) {
                        reqId = error.response.headers.get('X-Request-ID') || 'n/a';
                    }
                } catch (e) {
                    // Response not available (timeout case)
                }
                
                if (error.name === 'AbortError' || errorMsg.includes('aborted')) {
                    // Timeout - check server logs via /status endpoint to get recent Request IDs
                    errorMsg = '⚠️ Query timed out (took longer than 7 minutes).\n\n' +
                               'Your question is still in the box above - try simplifying it or breaking it into smaller parts.\n\n' +
                               'Check server console logs for Request ID, or visit http://localhost:8000/status to see recent requests.';
                } else if (errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError')) {
                    // Check if we're using Railway server or localhost
                    const isLocalhost = API_URL.includes('localhost') || API_URL.includes('127.0.0.1');
                    
                    if (isLocalhost) {
                        // Try to check if local server is running (async check)
                        const checkServer = async () => {
                            try {
                                const controller = new AbortController();
                                const timeoutId = setTimeout(() => controller.abort(), 2000);
                                const healthCheck = await fetch('http://localhost:8000/health', { 
                                    method: 'GET',
                                    signal: controller.signal
                                });
                                clearTimeout(timeoutId);
                                if (healthCheck.ok) {
                                    // Server is running - likely a timeout or processing issue
                                    return '⚠️ Connection lost. The query might be taking too long (large queries take 30-90 seconds).\n\n' +
                                           'Your question is still in the box above - just click "Ask Thunderclap" to try again, or simplify your question.\n\n' +
                                           'Check server console logs for Request ID, or visit http://localhost:8000/status to see recent requests.';
                                }
                            } catch (e) {
                                // Server is not running or not accessible
                                return '⚠️ Server is not running.\n\n' +
                                       'Please start the server by running: python server.py\n\n' +
                                       'Then try your query again.';
                            }
                            return '⚠️ Connection lost. Please check if the server is running: python server.py';
                        };
                        
                        // Show checking message immediately, then update when check completes
                        errorMsg = '⚠️ Connection lost. Checking server status...';
                        // Update tab with error (if tab exists)
                        if (typeof tabId !== 'undefined' && tabId) {
                            updateTab(tabId, {
                                status: 'error',
                                error: errorMsg
                            });
                        }
                        checkServer().then(msg => {
                            // Update tab with final error message
                            if (typeof tabId !== 'undefined' && tabId) {
                                updateTab(tabId, {
                                    status: 'error',
                                    error: msg
                                });
                            }
                        }).catch(() => {
                            // If check fails, show server not running message
                            if (typeof tabId !== 'undefined' && tabId) {
                                updateTab(tabId, {
                                    status: 'error',
                                    error: '⚠️ Server is not running.\n\nPlease start the server by running: python server.py\n\nThen try your query again.'
                                });
                            }
                        });
                    } else {
                        // Using Railway server - show generic connection error
                        errorMsg = '⚠️ Connection lost. The server might be temporarily unavailable or the query is taking too long.\n\n' +
                                   'Your question is preserved above - just click "Ask Thunderclap" to try again, or wait a moment and retry.\n\n' +
                                   'If this persists, the Railway server may be experiencing issues.';
                        // Update tab with error (if tab exists)
                        if (typeof tabId !== 'undefined' && tabId) {
                            updateTab(tabId, {
                                status: 'error',
                                error: errorMsg
                            });
                        }
                    }
                    // Skip default error display - we handle it above
                    document.getElementById('result').classList.add('show', 'error');
                    return; // Exit early to prevent default error display below
                } else if (errorMsg.includes('Token quota') || errorMsg.includes('token quota') || errorMsg.includes('250,000 tokens')) {
                    errorMsg = '⚠️ Token quota exceeded (250,000 tokens/minute). Your query uses too many tokens.\n\n' +
                               'Please wait 1-2 minutes and try again, or simplify your question to use fewer chunks.\n\n' +
                               'Your question is preserved above - just click "Ask Thunderclap" when ready.';
                } else if (errorMsg.includes('quota exhausted') || (errorMsg.includes('quota') && errorMsg.includes('exhausted') && errorMsg.includes('daily'))) {
                    errorMsg = '⚠️ API daily quota exhausted. Please wait and try again later, or check your API quota limits.\n\n' +
                               'Your question is preserved above - just click "Ask Thunderclap" when ready.';
                } else if (errorMsg.includes('rate limit') || errorMsg.includes('429') || (errorMsg.includes('quota') && !errorMsg.includes('exhausted'))) {
                    errorMsg = '⚠️ API rate limit reached. Please wait 30-60 seconds and try again.\n\n' +
                               'Your question is preserved above - just click "Ask Thunderclap" when ready.';
                } else {
                    errorMsg = '⚠️ Something went wrong: ' + errorMsg + '\n\nYour question is preserved - try clicking "Ask Thunderclap" again.';
                    if (reqId !== 'n/a') {
                        errorMsg += '\n\nRequest ID: ' + reqId;
                    }
                }
                // Update tab with error (if tab exists) - don't use old 'answer' element
                if (typeof tabId !== 'undefined' && tabId) {
                    updateTab(tabId, {
                        status: 'error',
                        error: errorMsg
                    });
                }
                document.getElementById('result').classList.add('show', 'error');
            } finally {
                // Clear progress timeout and hide loading
                clearTimeout(progressTimeout);
                while (bumps.length) clearTimeout(bumps.pop());
                document.getElementById('loading').classList.remove('show');
                // Reset progress UI after a short delay
                setTimeout(() => {
                    setProgress(0, 'Analyzing your query...');
                    document.getElementById('progress-container').style.display = 'none';
                }, 600);
                document.querySelector('button').disabled = false;
                // Ensure timer is cleared
                if (typeof timerInterval !== 'undefined' && timerInterval) {
                    clearInterval(timerInterval);
                }
                if (window.currentTimerInterval) {
                    clearInterval(window.currentTimerInterval);
                }
            }
        }
        
        // Progress helpers
        function setProgress(percent, text) {
            const bar = document.getElementById('progress-bar');
            if (!bar) return;
            const p = Math.max(0, Math.min(100, percent));
            bar.style.width = p + '%';
            if (text) {
                const details = document.getElementById('loading-details');
                if (details) details.textContent = text;
            }
        }
        function bumpProgress(delta) {
            const bar = document.getElementById('progress-bar');
            if (!bar) return;
            const current = parseInt(bar.style.width || '0', 10) || 0;
            setProgress(Math.min(95, current + delta));
        }
        
        // Attach event listeners when DOM is ready
        function attachEventListeners() {
            // Ask Thunderclap button
            const askBtn = document.getElementById('ask-thunderclap-btn');
            if (askBtn) {
                askBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('Ask Thunderclap button clicked');
                    askQuestion();
                });
                console.log('✅ Ask Thunderclap button listener attached');
            } else {
                console.error('❌ Ask Thunderclap button not found!');
            }
            
            // View Sample Terms button
            const sampleBtn = document.getElementById('view-sample-terms-btn');
            if (sampleBtn) {
                sampleBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('View Sample Terms button clicked');
                    showIndexed();
                });
                console.log('✅ View Sample Terms button listener attached');
            } else {
                console.error('❌ View Sample Terms button not found!');
            }
            
            // Allow Enter key to submit
            const questionInput = document.getElementById('question');
            if (questionInput) {
                questionInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        askQuestion();
                    }
                });
                console.log('✅ Enter key listener attached');
            }
        }
        
        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', attachEventListeners);
        } else {
            // DOM already loaded
            attachEventListeners();
        }
        
        // Debug: Log when page loads
        console.log('Thunderclap AI loaded. API URL:', API_URL);
        console.log('askQuestion function defined:', typeof askQuestion);
        console.log('showIndexed function defined:', typeof showIndexed);
        console.log('Version:', window.THUNDERCLAP_VERSION || 'UNKNOWN - OLD VERSION DETECTED!');
        
        // Visual indicator that new version is loaded
        if (window.THUNDERCLAP_VERSION === '7') {
            console.log('✅ NEW VERSION LOADED - Timer, Tabs, Platinum Theme enabled');
        } else if (window.THUNDERCLAP_VERSION) {
            console.log('⚠️ Version', window.THUNDERCLAP_VERSION, 'loaded (expected 7)');
        } else {
            console.warn('⚠️ Version not detected - may be cached');
        }
        
        // Ensure functions are globally accessible (for backward compatibility)
        window.askQuestion = askQuestion;
        window.showIndexed = showIndexed;
        console.log('Functions registered globally:', { askQuestion: typeof askQuestion, showIndexed: typeof showIndexed });
    </script>
</body>
</html>

